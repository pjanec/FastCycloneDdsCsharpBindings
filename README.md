# Cyclone DDS Csharp Bindings

High-performance .net implementation with zero-allocation pub/sub.

## Features

- ✅ Zero-copy writes via serdata APIs
- ✅ Zero-copy reads via loaned buffers
- ✅ User-space CDR serialization (no marshalling)
- ✅ True zero GC allocations on hot paths
- ✅ ArrayPool buffer pooling
- ✅ Lazy deserialization

## Architecture

### Write Path
1. Generate serialization code (Stage 2)
2. Serialize to CDR format in pooled buffer
3. Create serdata from CDR bytes
4. Write serdata to DDS (zero-copy)

### Read Path
1. Take serdata from DDS (zero-copy loan)
2. Extract CDR bytes from serdata
3. Lazy deserialize on access
4. Return loan when scope disposed

## Current Limitations (Stage 3)

**Supported Types:**
- ✅ Primitives (int, double, bool, etc.)
- ✅ Fixed-size structs
- ✅ Nested structs (fixed-size)

**Not Yet Supported (Stage 4/5):**
- ⏳ Sequences and strings (dynamic allocation required)
- ⏳ Arrays (T[])
- ⏳ Optional fields
- ⏳ Unions with complex types

**Platform Support:**
- ✅ Windows x64


## Usage

The API is designed to feel like standard modern C#, hiding the complex P/Invoke, memory management, and serialization logic.

---

### 1. Defining Your Data (The Schema)
You define your data using standard C# `partial structs` decorated with attributes. You do **not** run an external IDL compiler manually; the C# build process handles it.

```csharp
using CycloneDDS.Schema;

[DdsTopic("SensorData")] // Defines the DDS Topic Name
public partial struct SensorData
{
    [DdsKey] // Defines this field as the unique instance key
    [DdsId(0)] // field ordinals are optional, allowing you to change the order later without breaking compatibility
    public int SensorId;

    [DdsId(1)]
    public double Value;

    // Zero-Allocation String (Fixed buffer)
    // Fastest option, maps to char[32] in IDL
    [DdsId(2)]
    public FixedString32 LocationId; 

    // Managed String (Heap Allocated)
    // Slower, but convenient. Requires [DdsManaged] to opt-in to GC.
    [DdsId(3)]
    [DdsManaged] // without this, compiler rejects the heap-allocated stuff. Promotes using 'fast' data types.
    public string? LogMessage;
    
    // Sequences
    [DdsId(4)]
    [DdsManaged]
    public List<double> History;
}
```

### 2. Initialization
You create a Participant (the DDS node) and register your type.

```csharp
using CycloneDDS.Runtime;

// 1. Create the Participant on Domain 0
using var participant = new DdsParticipant(0);

// 2. Register Type Support (Generates the internal Topic Descriptor)
// This uses the generated bytecode to tell Cyclone about your type layout
var topicDesc = DdsTypeSupport.Register<SensorData>(participant);
```

### 3. Publishing Data (The Writer)
The API is designed for **Zero-Allocation** writes.

```csharp
// Create the Writer
using var writer = new DdsWriter<SensorData>(participant, "SensorData", topicDesc);

// Create your data (Stack allocated struct)
var sample = new SensorData 
{
    SensorId = 101,
    Value = 25.4,
    LocationId = new FixedString32("Factory_A"),
    LogMessage = null // Optional
};

// WRITE
// Internally: Serializes to pooled memory -> dds_create_serdata -> dds_write
// Cost: 0 GC Allocations
writer.Write(sample);

Thread.Sleep(1000);

// Dispose (Deletes the instance from the system)
// Value is ignored, only Id (Key) matters
writer.Dispose(sample);

```

### 4. Subscribing to Data (The Reader)
Reading uses a **Scope** pattern to ensure safety and zero-copy semantics. You "loan" the data, read it, and return it by disposing the scope.

```csharp
// Create the Reader
using var reader = new DdsReader<SensorData, SensorData>(participant, "SensorData", topicDesc);

// POLL FOR DATA
// Returns a "ViewScope" which is a ref struct (cannot escape stack)
using var scope = reader.Take(maxSamples: 10);

// Iterate received data
for (int i = 0; i < scope.Count; i++)
{
    // Check if this is valid data (not just a metadata update)
    if (scope.Infos[i].ValidData != 0)
    {
        // LAZY ACCESS
        // Deserialization happens ONLY here, when you access the indexer.
        // If you don't touch scope[i], no CPU is spent parsing it.
        SensorData data = scope[i];
        
        Console.WriteLine($"Received: {data.SensorId} = {data.Value}");
    }
}

// When 'using scope' ends:
// 1. Internal Serdata handles are unreferenced
// 2. Pooled memory buffers are returned to Arena
// 3. No GC cleanup required
```

### 5. Advanced Configuration (QoS)
You can apply QoS attributes directly to your schema or pass them during creation.

```csharp
[DdsTopic("CriticalAlarms")]
[DdsQos(
    Reliability = DdsReliability.Reliable, 
    Durability = DdsDurability.TransientLocal,
    HistoryKind = DdsHistoryKind.KeepLast,
    HistoryDepth = 10)]
public partial struct Alarm { ... }
```

### Key Differences from Old Implementation

1.  **No `new` keywords in loops:** API returns a `ViewScope` (struct) wrapping native handles.
2.  **`FixedString` types:** You explicit visibility into fixed-size buffers vs heap-allocated strings.
3.  **Lazy Deserialization:** The `ViewScope` allows you to inspect metadata (Info) before paying the cost of deserializing the payload.

This API surface meets the requirement of feeling like "idiomatic C#" while strictly enforcing the discipline required for high-performance systems.

### Disposing samples

To send a disposal message (which tells Subscribers that a specific instance Key is no longer valid/alive), you call writer's `Dispose` method with argument.

```csharp
// 1. Define type 
[DdsTopic("Sensor")]
public partial struct SensorData
{
    [DdsKey] public int Id; // Key field (if any) MUST be filled before disposing
    public double Value;    // other fields do not need to have valid value when disposing
}

// 2. Usage
using var writer = new DdsWriter<SensorData>(...);

// Update
writer.Write(new SensorData { Id = 1, Value = 100 });

// Dispose (Deletes the instance from the system)
// Value is ignored, only Id (Key) matters
writer.Dispose(new SensorData { Id = 1, Value = 0 }); 
```

### What happes when you dispose?

The Reader receives a notification that the data is no longer valid (NOT_ALIVE_DISPOSED).

Subsequent attempts to read data might fail or return no data, depending on the Reader's state mask. 


### Unregistering instances


```csharp
// 1. Writer comes online
var writer = new DdsWriter<RobotState>(...);

// 2. Writer sends data (Key: RobotID=5)
writer.Write(new RobotState { RobotID = 5, Status = "Moving" });

// 3. Writer goes offline gracefully
// This tells readers "I am gone", preventing them from waiting for heartbeats
writer.Unregister(new RobotState { RobotID = 5 });

// 4. Clean up
writer.Dispose();
```

### What happens when you Unregister?

1.  **Network:** A specific message is sent to all Readers indicating that *this* DataWriter is giving up ownership of the instance defined by the Key.
2.  **Readers:**
    *   If **Ownership Strength** is Exclusive (`EXCLUSIVE_OWNERSHIP_QOS`): The Reader will switch to the next highest strength Writer (failover).
    *   If **Shared** (default): The instance state changes to `NOT_ALIVE_NO_WRITERS` *only if* no other writers are alive for that instance.
3.  **Memory:** It releases resources associated with that instance in the Writer's local history cache.


### Unregister vs Dispose

*   **Dispose:** "This instance is dead/deleted." (Reader gets `InstanceState = NotAliveDisposed`)
*   **Unregister:** "I am no longer updating this instance, but it might still exist." (Reader gets `InstanceState = NotAliveNoWriters`)



## Dependencies

- CycloneDDS.Core (CDR serialization)
- CycloneDDS.Schema (attributes)
- ddsc.dll (native Cyclone DDS library, extended by exposing serdata manipulation methods - needs a custom build)

## Next Steps

See `docs/SERDATA-TASK-MASTER.md` for Stage 4+ roadmap.



# Detailed Overview
FastCycloneDDS C\# Bindings is a .NET library that provides a high-performance interface to the Eclipse Cyclone DDS middleware. It enables C\# applications to publish/subscribe DDS topics with minimal overhead by eliminating GC allocations and leveraging Cyclone’s native serialization (XCDR2). The binding introduces a C\#-based DSL for defining topic data structures using attributes and custom types, and a zero-copy read/write path for maximum throughput.

## **Features at a Glance**

* **Zero-Allocation Serialization:** Uses a custom CDR serializer (XCDR2 Appendable) implemented in C\#, ensuring no garbage collection overhead in steady-state publishing and receiving. Both fixed-size and variable-size data are handled with zero runtime allocations via pooled buffers.  
* **Direct DDS Integration (Serdata API):** Bypasses intermediate copies by interacting with Cyclone DDS at the serialized data level. Pre-serialized byte streams (“serdata”) are passed directly to Cyclone’s writer, and data is taken as raw CDR buffers on read, enabling an efficient single-copy data path.  
* C\# Domain-Specific Language for Topics: Define your DDS topic types in C\# with familiar constructs – use attributes to mark keys, optional fields, unions, etc., instead of separate IDL files. The binding’s DSL supports primitives, structs, enums, strings, sequences, unions, and optional members with a rich attribute set for DDS-specific metadata.  
* **Managed vs Unmanaged Sample Support:** Choose between “hot-path” unmanaged structs (blittable, fixed-size data for maximum performance) and managed, GC-backed types (strings, lists, object references) for convenience. By default, types are treated as zero-copy structs; you can opt in to managed fields with a `[DdsManaged]` attribute when needed. This hybrid model provides fast paths for fixed data and allows managed data when necessary.  
* **Source-Generated Serialization Code:** At build time, a code generator emits efficient `Serialize()` / `Deserialize()` logic for your types. The generated code uses no reflection or boxing – it’s tailored to each type and JIT-optimizable, including precomputed alignment and size calculations. The serializer fully conforms to XCDR2 Appendable encoding (including delimiter headers for extensibility), ensuring on-the-wire compatibility with Cyclone DDS’s own serialization.  
* **Zero-Copy Reading via Views:** Data samples received from Cyclone can be accessed through ref struct “view” objects that reference the serialized buffer directly. This allows you to inspect or copy fields without allocating new objects. (You can still convert to owned C\# objects if desired for convenience.)  
* **Quality of Service and Type Mapping:** Specify DDS QoS policies right on your types (e.g. reliability, durability) with `[DdsQos]` attribute to control history, reliability, etc., at topic definition. You can also register global type mappings – for example, map a `System.Guid` or `DateTime` to a compact wire representation – using an assembly-level attribute (`[assembly: DdsTypeMap(typeof(T), DdsWire.SomeFormat)]`).

## Quick Example
Below is an example of defining a DDS topic type in C# and using the binding to publish and subscribe samples:

``` csharp
using CycloneDDS.Schema;
using CycloneDDS.Runtime;
using CycloneDDS.Schema.WrapperTypes;  // for FixedString and BoundedSeq

// 1. Define a topic data type using C# struct and attributes
[DdsTopic("ExampleTopic")]                // Mark this struct as a DDS Topic type
[DdsQos(Reliability = DdsReliability.BestEffort)] // Example: set QoS (if different from defaults)
public partial struct ExampleData
{
    [DdsKey] public int Id;               // Mark 'Id' as the key field for the topic
    public double Value;                  // A regular field (primitive types supported)
    [DdsManaged] public string? Label;    // A managed field (string) – requires [DdsManaged] to allow GC allocation
    public FixedString32 Tag;             // An unmanaged fixed-size string (32-byte UTF-8 buffer)
    [DdsManaged] public List<int>? Numbers;   // A dynamic sequence (List<int>) as a managed field
    public BoundedSeq<float> Metrics;     // A bounded sequence of floats (capacity set in constructor)
    
    // (The code generator will add Serialize/Deserialize methods here)
}

// 2. Initialize DDS participant and register the ExampleData type
using var participant = new DdsParticipant(domainId: 0);
IntPtr typeDesc = ExampleDataTypeSupport.Register(participant); 
// ^ The codegen produces ExampleDataTypeSupport with embedded type metadata.

// 3. Create a Writer and Reader for the topic
using var writer = new DdsWriter<ExampleData>(participant, "ExampleTopic", typeDesc);
using var reader = new DdsReader<ExampleData, ExampleData>(participant, "ExampleTopic", typeDesc);

// 4. Publish a sample
ExampleData sample = new ExampleData {
    Id = 42, 
    Value = 3.14, 
    Label = "Hello DDS",                    // using a GC-managed string
    Tag = new FixedString32("SensorA"),     // fixed-size string (no GC allocation)
    Numbers = new List<int> {1, 2, 3},      // managed list
    Metrics = new BoundedSeq<float>(capacity: 10)  // bounded seq (max 10 floats)
};
sample.Metrics.Add(0.99f);
writer.Write(in sample);  // Serialize and write the sample

// 5. Subscribe and take samples
using var samples = reader.Take();         // Loan samples (no copy)
foreach (var view in samples)              // View each sample in the loan
{
    Console.WriteLine($"Received Id={view.Id}, Value={view.Value}, Label={view.Label}");
    // 'view' is an ExampleData struct populated from the received data.
    // It includes both unmanaged data (Value, Tag) and managed (Label, Numbers) as defined.
}

```

**How it works:** When writer.Write(sample) is called, the binding invokes generated code to serialize ExampleData into the CDR binary format. The serialization honors the XCDR2 appendable encoding – for instance, if ExampleData were marked appendable or had optional fields, a 4-byte header and any presence flags would be included automatically. The bytes are written into a pooled buffer (avoiding any new allocations) and then handed off to Cyclone DDS via a native API that accepts an already-serialized data buffer. On the subscriber side, reader.Take() leverages Cyclone’s loaned sample API to retrieve raw data pointers with no copying. Each view in the ViewScope is a lightweight struct that deserializes fields on demand from the CDR buffer. In this example, accessing view.Label triggers allocation of a new string (since Label was declared as managed), whereas view.Value and other value types are read directly from the buffer with no GC overhead.


## **Technical Analysis and Architecture**

### **Zero-Allocation, High-Throughput Serialization (XCDR2 Appendable)**

**Performance Goal:** The core design principle of this binding is “zero-allocations” in steady-state communication. This is achieved by flattening each DDS sample into a contiguous binary representation (CDR) and interfacing directly with Cyclone DDS at that binary level. Instead of marshalling data through intermediate C structures or per-field heap objects, the binding uses a single contiguous buffer per sample and recycles buffers via pooling.

**Custom CDR Implementation:** The library implements the *Extended Common Data Representation (XCDR2)* serialization in pure C\#. It supports **Appendable** types, meaning the serialized form includes a 4-byte delimiter header and (when needed) optional field bitmaps, allowing forward and backward compatibility (type extensibility). The generated code automatically handles this: before writing a struct’s fields, it aligns and reserves space for the 4-byte length header and later fills it with the serialized body length. If the type has optional members (e.g. `Nullable<T>` fields) or is explicitly marked appendable (`[DdsAppendable]`), the serializer writes the extensibility (EM) header bits indicating which optional fields are present. This ensures the output conforms exactly to Cyclone’s expectations for Appendable types.

Notably, the code generator assigns each field a *Member ID* (by default the field order, or explicitly via `[DdsId(n)]` attribute) and orders serialization by increasing ID. This matches DDS XTypes rules for consistent ordering and optional field indexing. Union types are handled with a discriminator and case labels in the serialized stream, exactly as in IDL – the generated code writes the discriminator then only the active union member, using a switch-case over the cases marked with `[DdsCase(...)]` attributes. 

**Single Copy Data Path:** On the write path, the binding avoids multiple memory copies: the data goes *directly from the user object into the output buffer*, and then straight into Cyclone’s internal structures. For example, when calling `writer.Write(sample)` on a `DdsWriter<T>`, it will: (1) calculate the exact size of the CDR payload (using a generated `GetSerializedSize` method) with proper alignment, (2) rent a buffer of that size from the `ArrayPool<byte>` (no allocation), (3) write the standard CDR encapsulation header (for little-endian CDR: 4 bytes 0x00\_01\_00\_00), and then (4) invoke the generated `Serialize(ref CdrWriter writer)` method to encode the sample’s fields into the buffer. Once serialized, an internal P/Invoke call `dds_create_serdata_from_cdr` is used to hand this raw CDR byte array to Cyclone DDS, creating a `serdata` object in Cyclone’s terms. Finally, the code calls `dds_writecdr` (a custom extension function) to publish the serdata directly via the DDS DataWriter. At no point are individual fields allocated on the heap during this process – even complex fields like strings or sequences are serialized straight into the byte stream (strings are UTF-8 encoded, sequences are preceded by length and then elements written in-line).

**Zero-Copy Reads (Loaned Buffers):** On the subscribe path, the binding uses Cyclone DDS’s loan mechanism to avoid upfront copying of data. A `DdsReader<T,TView>` is created with knowledge of the topic’s type descriptor. When `reader.Take()` is called, it invokes a native function `dds_takecdr` (added in this binding) which returns pointers to the serialized data for up to N samples, along with their info (sample state, source timestamp, etc.). These pointers reference Cyclone’s internal `serdata` buffers containing the CDR data. The binding wraps them in a `ViewScope<TView>`, which exposes a span of `SampleInfo` and allows indexing into the samples without yet converting them. This design means you can inspect how many samples were received and even peek at the `SampleInfo` (to check validity, timestamps, etc.) before incurring any serialization cost.

When you do access a sample (e.g. `var data = samples[i]`), the binding performs lazy deserialization: it will take the `IntPtr` for that sample’s serdata, determine its size via `ddsi_serdata_size` (a Cyclone internal API exposed to .NET), rent a buffer of that size, and call `ddsi_serdata_to_ser` to extract the raw CDR bytes from the serdata object into the buffer. (Cyclone stores data in a form ready to be sent over network; this call provides a contiguous copy in CDR format.) Then a `CdrReader` is initialized on the byte span and advanced past the 4-byte encapsulation header (the serializer always includes it). Finally, the generated static `Deserialize(ref CdrReader)` method for the type is invoked to produce a `TView` result. This `TView` is typically a struct representing the data fields – it may be the same as `T` or a lighter-weight view type. The key is that only the fields are populated, and any managed objects (like strings in the sample) are allocated at this point if needed. The library thereby avoids allocating *anything* for samples you don’t actually examine, and defers per-sample overhead to just when you use it. After you finish with the view scope, calling `Dispose()` on it will release the pooled buffers and return the loan to Cyclone, including decrementing references to the serdata objects so Cyclone can clean up.

**Memory Management:** Throughout this pipeline, memory reuse is heavily employed. The `Arena` memory manager simply wraps .NET’s `ArrayPool<byte>` for buffer rentals. All buffers for serialization and deserialization come from this shared pool, meaning no garbage is produced for each sample (buffers are returned to the pool). Likewise, arrays for holding pointers and sample info on read are pooled and reused. The use of `ref struct` for view scopes ensures that the reader’s buffers can’t be accidentally persisted beyond the scope (enforced by the compiler), preventing misuse of loaned data. In essence, the design achieves zero GC allocations on the hot path for both publishing and subscribing, as intended. Any unavoidable allocations (e.g. a new string object for a received string field) occur only when using convenience features and are explicitly opted into by the user via `[DdsManaged]` (discussed below).

Finally, to guarantee that this custom CDR serialization is correct and interoperable, the project employs *golden tests*: a given struct serialized via the C\# `CdrWriter` is compared byte-for-byte with the serialization from Cyclone’s native implementation. This ensures the alignment, endianness, and encoding (especially for complex types) exactly match Cyclone DDS’s standard, which is crucial for seamless interoperability in a DDS environment.

### **C\# DSL for DDS Topic Types**

The binding provides a *schema definition DSL* in C\# that mirrors the capabilities of IDL (Interface Definition Language) used in DDS, but in a familiar C\# syntax. Users define their topic data types as C\# `struct` or `class` types and annotate them with attributes from the `CycloneDDS.Schema` namespace to convey DDS-specific intent (topic names, keys, etc.). The code generator processes these definitions to produce serialization code and register the types with Cyclone.

Key components of the DSL include:

* **`[DdsTopic]` Attribute**: This attribute marks a C\# `class` or `struct` as a DDS topic type. It takes a topic name as a parameter, which will be used when creating the DDS Topic in the participant. Example: `\[DdsTopic("SensorData")\] public partial struct SensorData { ... }`. Only types marked with `DdsTopic` are processed by the code generator for DDS integration.  
* **`[DdsKey]` Attribute:** Used to designate one or more fields as the *key* of the topic (for keyed DDS topics). A key field uniquely identifies an instance (for DDS keyed DataWriters/DataReaders and instance-level lifecycle). In our example above, we used `[DdsKey] public int Id;` to mark the `Id` field as the key. Under the hood, key fields are noted in the type’s descriptor (the `dds_topic_descriptor_t` has a key count and key list). Marking keys ensures the generated type support registers the key information with Cyclone. (If no key is marked, the topic is treated as *keyless* like an IDL struct with no key.)  
* **`[DdsManaged]` Attribute:** This attribute can be applied to a field or an entire type to indicate that the normal zero-allocation rules are relaxed for that member/type. In practice, this is required for any field of a *managed reference type* (e.g. `string`, `List<T>`, or any class) and for any topic type that contains such fields. The generator’s validator ensures that if you use a managed type, you explicitly annotate it, otherwise it will raise an error. The rationale is to make you conscious of performance trade-offs. For example, `public string Label;` must be marked `[DdsManaged]` as shown, because it will involve heap allocation (on write, encoding the string; on read, constructing a new string). Similarly, if a struct as a whole is meant to allow managed fields, you might mark the struct `[DdsManaged]` to signal it’s not fully POD. If you prefer to avoid GC completely, you would use alternative types (like fixed-size strings or arrays) instead of marking fields as managed.  
* **Fixed-Size String Wrappers:** To facilitate unmanaged usage of textual data, the library provides FixedString32, FixedString64, and FixedString128 struct types. These are value-types containing an inline fixed byte buffer of the specified length (e.g. 32 bytes) to hold a UTF-8 string with NUL termination. They behave like `char` arrays but are safe and provide conveniences: you can construct them from a C\# string (which will be UTF8-encoded into the fixed buffer, throwing an exception if the string is too long), and you can convert them back to `string` when needed (`ToStringAllocated()` method). Using a FixedString type in your data struct means the string is embedded in the sample’s memory layout – no separate allocations per sample, and serialization simply dumps the 32 bytes as part of the struct. In the DSL, you just declare a field of type `FixedString32` etc. (as we did with `Tag` above) and it’s treated as a fixed-length string\<sup\>32\</sup\> in DDS terms. This is ideal for fixed-size identifiers, tags, or labels that have a known max length.  
* **Sequences and Arrays:** Variable-length arrays (sequences in DDS terminology) can be represented in two ways. If you want a bounded sequence with a maximum capacity (to avoid unbounded allocations), you can use the provided `BoundedSeq<T>` struct. `BoundedSeq<T>` wraps a `List<T>` internally but pre-allocates it to a fixed capacity and will not allow growth beyond that. It’s a struct to maintain value-semantics but note it still uses a managed `List<T>` internally for convenience, so it is not fully allocation-free; however, by capping the capacity and reusing the list, you control the max allocations. In your topic type, you would declare e.g. `public BoundedSeq<float> Metrics;` and construct it with a capacity (as shown in the example). The code generator treats `BoundedSeq<T>` as a sequence: on write, it will serialize it similar to a list (writing length and elements) but it knows the maximum length from the capacity. Alternatively, for truly dynamic sequences (unbounded or not known at compile time), you can use standard C\# collections like `List<T>` or arrays `T[]` as fields, but these are considered *managed*. In fact, as of the latest design, `List<T>` is supported as a managed sequence type (requiring `[DdsManaged]`), whereas raw `T[]` might not be directly supported (the focus is on List for dynamic arrays). If you use `List<T>`, the serializer will write the length (as a 32-bit count) then each element. It even has an optimization for lists of primitive types: it will copy the internal array in bulk when possible for speed. For non-primitive list elements, it loops and serializes each (`Serialize()` for structs, or writes for strings, etc.). The DSL allows you to choose: for absolute speed and predictability, use `BoundedSeq` (or even a fixed-length array via `[DdsArray(length)]` attribute if implemented); for ease, use `List<T>` with the understanding that it will allocate and copy.  
* **Optional Members:** The DSL supports optional fields following the DDS XTypes optional semantics. In C\#, you can declare a field as `T?` where T is a value type (e.g. `public int? optionalCount;`). The generator recognizes nullable value types and implements them with the XCDR2 *presence flag* mechanism (EM header bitmask). If the field has a value, a bit is set in the header and the value is serialized; if it’s null, the bit is 0 and no value bytes appear on the wire. This corresponds to IDL `@optional` members. For reference types, since any reference can be null in C\#, they are conceptually optional already – the generator could treat a `[DdsManaged] string?` similarly (writing nothing if null). The handling of null strings is configurable; by default the design prefers preserving null vs empty string distinctly. The key point is that optional fields are fully supported in the serialization format, aiding in schema evolution (you can add a new optional field later without breaking older readers).  
* **Unions:** DDS unions (discriminated union types) are represented by marking a struct with `[DdsUnion]`. Inside, one field must carry `[DdsDiscriminator]` to indicate the discriminant (often an enum or int), and each union member field gets a `[DdsCase(...)]` attribute listing one or more discriminant values that select that field. An optional `[DdsDefaultCase]` can mark the field used for any discriminant value not explicitly handled. In the C\# type, all union case fields typically share the same memory (in an actual union this would be overlapping, but here the generator ensures only the active one is read/written based on the switch). The generated serializer writes the discriminator followed by the active field’s value (all others are ignored), and the deserializer will return a view struct with only the matching field populated. Union support means you can translate an IDL union directly into a C\# `[DdsUnion] partial struct` and get identical on-wire behavior.  
* **Enum types:** C\# enums are supported natively (treated as their underlying integral type in serialization). The DSL simply uses the enum as a field type; the generator will write it as a numeric value (commonly 32-bit). There’s usually no special attribute needed for enums.  
* **Type Identification and Extensibility:** By default, the fully qualified name of the C\# type (namespace \+ type name) is used as the DDS type name. The code generator and type support ensure that Cyclone DDS is aware of this name and the type’s hash (if using XTypes). You can override or map types if needed. For example, the assembly-level `[DdsTypeMap]` attribute can map a C\# type to a specific wire format or Cyclone internal type code. The provided `DdsWire` enum includes some common mappings – e.g. `Guid16` to treat a `System.Guid` as 16 bytes on the wire, `QuaternionF32x4` to treat a 4-float struct as a special sequence, etc.. Using `DdsTypeMap(typeof(Guid), DdsWire.Guid16)` in an assembly instructs the system that whenever a `Guid` appears in a topic, it should be serialized as 16-octet sequence (and the codegen will call the appropriate `WriteGuid` method). This extensibility allows integration of custom types without modifying the core, as long as you define how they map to primitive sequences.

**Example Summary:** In sum, the DSL lets you define a topic type like `ExampleData` with rich semantics entirely in C\#. The attributes `[DdsTopic("ExampleTopic")]` and `[DdsKey]` mirror IDL’s topic and key declarations. The presence of both unmanaged (`FixedString32`, primitive types) and managed (`string`, `List<int>`) fields in `ExampleData` demonstrates the hybrid approach – the codegen will enforce that `ExampleData` is marked `[DdsManaged]` (since it has managed fields) and handle each field appropriately. At runtime, Cyclone DDS sees a type that matches what an equivalent IDL definition would produce.

### **Managed vs Unmanaged Samples: Choosing the Representation**

**Unmanaged (Blittable) Sample Structs – The Hot Path:** For highest throughput and lowest latency, define your DDS samples as *plain old data* structs – containing only value types or fixed-size value wrappers. An unmanaged sample has no object references and a fixed memory footprint. Such a struct can be directly written to the wire without any extra copying and can even be memory-mapped to Cyclone’s internal representation when using loaned writes. In practice, this means using types like `int, float, double, etc.`, fixed-size arrays, `FixedStringN`, and other structs (which themselves are unmanaged or blittable). Avoid `string`, `List`, or any reference types in these definitions. The binding does not require you to mark purely unmanaged structs with any special attribute – by default everything is treated as zero-copy capable. If you follow this pattern (no `[DdsManaged]` anywhere in the type), the library ensures end-to-end data handling occurs with no GC involvement. For example, you might represent a sensor measurement as:

``` csharp
[DdsTopic("AccelSamples")]
public partial struct AccelSample  // no [DdsManaged] – fully unmanaged
{
    [DdsKey] public uint SequenceId;
    public float X, Y, Z;
    public FixedString32 SensorID;
}
```

Here, publishing and receiving `AccelSample` will be extremely efficient: 0 heap allocations, and the data can be read straight out of the network buffer. This is the **recommended pattern for high-rate topics or large data streams**, where GC pauses or excessive copying would be unacceptable.

**Managed Fields and Samples – When to Use:** Sometimes, flexibility or ease of use trumps absolute performance. For example, you may have variable-length text or arrays that don’t have a natural fixed maximum, or you simply prefer using `string` and `List<T>` for convenience. The binding allows these, but you must opt in via `[DdsManaged]`. A *managed sample* (one that is marked `[DdsManaged]` or contains managed fields) will incur some allocations: e.g., every time you publish a sample with a `string` field, the UTF-8 encoding step allocates a byte\[\] (though from pool) and on the subscribe side, constructing the `string` object itself hits the GC. Similarly, a `List<T>` may allocate an array internally as it grows or when it’s materialized on the receiving end. The library’s philosophy is to make these costs explicit. By tagging such fields, you declare “I accept the GC overhead for this data.” The code generator even includes a validator that will produce a compile-time diagnostic if you forgot to mark a managed field – this prevents accidental performance degradation.

Use managed representations when:

* The data size is not critical or the publish rate is low (so a few allocations won’t matter).  
* The convenience of built-in C\# types is desired – e.g., using `string` for unbounded text, or `List<T>` for a truly dynamic list.  
* You need to interface with other code that requires actual C\# reference types (e.g., UI or business logic that works with `string` objects).

**Bridging Between Representations:** The binding is designed so that you can often mix and match. For instance, you might define a type with unmanaged representation for core fields and use managed only for rarely-used or ancillary data. On the receive side, you could even choose to access data via the view (to avoid copying) or convert it to a fully managed object. The generated view structs typically provide a method (or you can easily write one) to **“own” the data**, meaning deep-copy it into a new C\# object. In the old architecture, this was done via an `IMarshaller` or a `ToOwned()` method on the view. In the current design, you can achieve a similar result by simply assigning the view struct to a managed struct or class if needed, or by writing a small utility. For example, if you have a `FixedString32 name` but want a `string`, you call `name.ToString()` (which allocates a new string from the UTF8 bytes). Or if you have a `BoundedSeq<T>`, you can get a `List<T>` from it (since it’s essentially a wrapper around a `List<T>`) by calling `.AsSpan()` or iterating – note that `BoundedSeq<T>` is a struct but shares its internal list reference on copies. The takeaway: the system doesn’t leave you stuck – you can always convert an unmanaged representation to a managed one when needed, it’s just a deliberate step (and cost) that you control.

**Recommended Approach: Use unmanaged structs for the “hot path”** – high-frequency or large-volume data. This maximizes throughput and keeps latency consistent, as there’s no GC interference. For these types, design your messages with fixed maximum sizes (e.g., `FixedString128` instead of unbounded string, bounded sequences instead of unbounded, etc.). The performance difference is significant: unmanaged code paths avoid not only allocations but also runtime checks like pinning or buffer copies that managed objects require. On the other hand, for configuration data, occasional messages, or types where developer convenience is more important than micro-optimizations, feel free to use managed types with `[DdsManaged]`. The binding will handle them correctly – they are fully supported as first-class citizens (including nested objects/structures). Just be aware that under the hood, those will use the slower marshalling path (e.g., copying data into/out of native form) and cause some garbage.

In summary, **choose unmanaged sample definitions for performance-critical data**, and opt into managed fields only when necessary. If a project starts with certain fields as managed and you later identify them as a bottleneck, you can often refactor to an unmanaged equivalent (e.g., replace `string` with `FixedStringN`, or `List<int>` with `BoundedSeq<int>` of known max length) and update the readers accordingly. This flexibility allows tuning of the system without changing external interfaces – since from the DDS network perspective, a fixed string of length N vs a managed unbounded string (with max length N enforced) can be made to appear the same if you planned the IDL correctly. The binding’s DSL, coupled with attributes like `[DdsId]` and `[DdsAppendable]`, helps maintain compatibility in such evolutions.

### **Integration with Cyclone DDS Core (Native API Extensions)**

Under the hood, this binding works in tight coordination with the Cyclone DDS C library. Because we generate and handle the serialization in .NET, we bypass the normal Cyclone DDS IDL compiler output in the traditional workflow. To make this possible, the project had to extend Cyclone DDS’s C API (ddsc) with new entry points that accept our serialized data and type information directly. These are implemented in a custom build of Cyclone DDS (included in the repository) and exposed via P/Invoke to the C\# code:

* **Type Registration:** Before using a topic type in DDS (creating writers/readers), Cyclone needs a `dds_topic_descriptor_t` that describes the type (analogous to the generated code in an IDL-generated C file). The binding automates this by generating an IDL file on the fly from your C\# definition, running Cyclone’s `idlc` compiler, and extracting the resulting type descriptor data (TypeObject). It then calls a custom native API `dds_create_topic_descriptor_from_cdr(participant, typeName, descriptorBlob)` to register the type with Cyclone DDS at runtime. This function takes the serialized TypeDescriptor (XTypes TypeObject in CDR form) and installs it into the participant so that on the network, the type can be communicated and matched. In the example above, the `ExampleDataTypeSupport.Register(participant)` likely invokes this function, passing in a byte array that represents the type’s schema. As a result, from Cyclone’s perspective, the participant now knows about a type "ExampleTopicType" with certain size, keys, and serialization opcodes — even though Cyclone itself didn’t compile this type from IDL at build-time. This dynamic registration is crucial for **type discovery** in a dynamic binding like this.  
* **Writing Samples:** We discussed `dds_writecdr` earlier – this is the P/Invoke that takes a writer handle and a `serdata` pointer. Internally, this likely wraps Cyclone’s `dds_write` logic but allows providing already-serialized data. The sequence is: our code calls `dds_create_serdata_from_cdr(topic, dataPtr, size)` which uses the topic’s `sertype` (serialization type info in Cyclone) to create a `serdata` object from the raw bytes. Then `dds_writecdr(writer, serdata)` is called to enqueue that data into the writer’s queue for distribution. These functions are not part of standard Cyclone DDS; they were added to let an external entity (the C\# side) supply data in the expected format. Notably, when `dds_writecdr` succeeds, Cyclone takes ownership of the `serdata` (similar to how `dds_write` would take ownership of the sample memory in loaned mode), so the C\# code must not free it in that case. The binding handles this by not attempting to free the serdata after a successful write (and only potentially freeing on failure).  
* **Reading Samples:** On the subscriber side, the custom API `dds_take_cdr(reader, samplesBuffer, maxSamples, infoBuffer, stateMask)` was introduced. It behaves like `dds_take` but instead of requiring pre-allocated sample memory for each item, it returns pointers to internal serdata for each taken sample. The C\# binding calls this to fill an array of `IntPtr` (for data) and an array of `DdsSampleInfo` (mirroring Cyclone’s sample info struct). The returned count indicates how many samples were taken. At this point, no data has been copied; we just have references to Cyclone’s own stored data. Later, when the user accesses each sample, the binding uses two more internal hooks: `ddsi_serdata_size(serdata)` to get the length of the data buffer, and `ddsi_serdata_to_ser(serdata, offset, size, destBuffer)` to actually copy out the bytes into a C\# buffer for deserialization. These `ddsi_...` functions tap into Cyclone’s internal DDSI (implementation layer) API – they are not normally exposed, but the binding makes them available via P/Invoke for exactly this use-case. Finally, `dds_return_loan(reader, samplesBuffer, count)` is provided to return the loan when the view scope is disposed, though in our implementation the `ViewScope.Dispose()` manually unrefs each serdata instead of a bulk return. The principle remains: we ensure Cyclone knows we are done with the buffer so it can recycle or free it.  
* **Memory Alignment and Struct Matching:** The binding had to be very careful that the C\# side structures match the native structures Cyclone uses. For example, the `DdsSampleInfo` struct is replicated in C\# (with sequential layout) so that the sample info data can be read correctly. A static constructor check compares `sizeof(DdsSampleInfo)` in native vs managed to catch any mismatches. Similarly, when building the topic descriptor, the project uses an `AbiOffsets` helper to ensure offsets of fields in the `dds_topic_descriptor_t` and related structs (which can differ between platforms) are correctly accounted for when marshalling. In earlier versions, they programmatically parsed Cyclone’s C source to generate these offsets to avoid relying on `StructLayout` guesses. All these steps were necessary to extend Cyclone DDS safely – essentially, we’re injecting our own types and serialization, so we must speak Cyclone’s internal “ABI language” perfectly.

In summary, the C\# binding extends Cyclone DDS by providing new APIs for:

* **Dynamic type registration** from a TypeObject/descriptor blob.  
* **Supplying serialized data** to DataWriter without an IDL-generated type plugin.  
* **Retrieving raw serialized data** from DataReader without prior knowledge of the type in C.  
* Some utility functions for serdata manipulation and info structures.

These extensions make Cyclone DDS act as a sort of serialization-agnostic transport: the C\# side says “here’s bytes and a descriptor,” and Cyclone will distribute those bytes to matching subscribers. On the subscriber end, Cyclone gives the bytes back and the C\# side interprets them. The trust is that both sides share the same understanding of the type’s schema – which is ensured by using Cyclone’s own IDL compiler output as the source of truth for the descriptor and by adhering strictly to the XCDR2 serialization format. This design choice (leveraging Cyclone’s IDL compiler and internal APIs) was deliberate: it avoids re-implementing the entire XTypes specification from scratch and reduces the risk of incompatibility. By extracting Cyclone’s generated type metadata, the binding guarantees that “C\# entities appear exactly as the native writer expects them”.

**Conceptual Illustration:** The overall system looks like this – at build time, your C\# definitions go through a generator that (a) produces C\# serialization code (methods in partial classes) and (b) produces an IDL and registers the resulting type descriptor. At runtime, when you create a `DdsWriter<T>`, it registers the type (if not already) and creates a real DDS Topic and DataWriter in Cyclone using that descriptor. From then on, writing goes through our serializer into Cyclone via serdata, and reading comes via serdata out through our deserializer. The Cyclone DDS core handles discovery, matching, networking, and reliability as usual – it’s unaware that the actual serialization wasn’t done by its own generated code. From a DDS interoperability standpoint, other applications (in C++, etc.) can subscribe to the same topics as long as they share the IDL definition; they will interoperate perfectly, since on the wire it’s standard DDSI-RTPS data. The .NET binding essentially acts as a **bridge that speaks DDSI with Cyclone’s accent**, but gives .NET developers a safe and idiomatic way to define and use data.

---

**Conclusion:** The Fast Cyclone DDS C\# binding demonstrates a sophisticated integration approach: it offloads the heavy lifting of XCDR serialization to generated, optimized C\# code and uses Cyclone DDS as a robust transport layer, via carefully crafted API extensions. By using a C\# DSL with attributes, it abstracts away the IDL while still supporting all its features (keys, optional, unions, etc.). Performance is front-and-center – the design achieves zero allocations on the fast path, leverages zero-copy techniques with loaned buffers, and even aligns data for block copies where possible. This makes it suitable for demanding applications (robotics, vehicles, high-frequency telemetry) where .NET is desired but garbage collection must be kept at bay. At the same time, the binding remains flexible: developers can opt into GC-managed conveniences when needed and still use the same infrastructure. By extending Cyclone DDS rather than forking it, the project ensures that improvements in Cyclone (and compliance with the DDS standard) naturally benefit the .NET side. Overall, this binding marries the world of real-time friendly DDS with the productivity of C\#, without sacrificing the performance and wire-level interoperability that are the hallmarks of DDS.