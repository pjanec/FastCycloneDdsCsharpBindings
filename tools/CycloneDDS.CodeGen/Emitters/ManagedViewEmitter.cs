using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;

namespace CycloneDDS.CodeGen.Emitters;

public class ManagedViewEmitter
{
    private readonly StringBuilder _sb = new();
    
    /// <summary>
    /// Generate TManaged ref struct view for topic type.
    /// </summary>
    public string GenerateManagedView(TypeDeclarationSyntax type, string namespaceName)
    {
        _sb.Clear();
        
        var typeName = type.Identifier.Text;
        var managedTypeName = $"{typeName}Managed";
        var nativeTypeName = $"{typeName}Native";
        
        // File header
        EmitLine("// <auto-generated/>");
        EmitLine($"// Generated managed view for {typeName}");
        EmitLine();
        EmitLine("using System;");
        EmitLine();
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        
        // Ref struct declaration
        EmitLine($"/// <summary>");
        EmitLine($"/// Managed view over native {typeName} data.");
        EmitLine($"/// </summary>");
        EmitLine($"public ref struct {managedTypeName}");
        EmitLine("{");
        
        // Store reference to native
        EmitLine($"    private readonly ref {nativeTypeName} _native;");
        EmitLine();
        
        // Constructor
        EmitLine($"    internal {managedTypeName}(ref {nativeTypeName} native)");
        EmitLine("    {");
        EmitLine("        _native = ref native;");
        EmitLine("    }");
        EmitLine();
        
        // Emit property accessors
        var fields = type.Members.OfType<FieldDeclarationSyntax>().ToList();
        foreach (var field in fields)
        {
            EmitManagedProperty(field);
        }
        
        EmitLine("}");
        
        return _sb.ToString();
    }

    public string GenerateManagedUnion(TypeDeclarationSyntax type, string namespaceName)
    {
        _sb.Clear();
        
        var typeName = type.Identifier.Text;
        var managedTypeName = $"{typeName}Managed";
        var nativeTypeName = $"{typeName}Native";
        
        // File header
        EmitLine("// <auto-generated/>");
        EmitLine($"// Generated managed view for union {typeName}");
        EmitLine();
        EmitLine("using System;");
        EmitLine();
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        
        // Ref struct declaration
        EmitLine($"public ref struct {managedTypeName}");
        EmitLine("{");
        
        // Store reference to native
        EmitLine($"    private readonly ref {nativeTypeName} _native;");
        EmitLine();
        
        // Constructor
        EmitLine($"    internal {managedTypeName}(ref {nativeTypeName} native)");
        EmitLine("    {");
        EmitLine("        _native = ref native;");
        EmitLine("    }");
        EmitLine();
        
        // Discriminator property
        var discriminatorField = type.Members.OfType<FieldDeclarationSyntax>()
            .First(f => f.AttributeLists.SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString().Contains("Discriminator")));
        
        var discType = discriminatorField.Declaration.Type.ToString();
        var discName = discriminatorField.Declaration.Variables.First().Identifier.Text;
        
        EmitLine($"    public {discType} {discName} => _native.{discName};");
        EmitLine();
        
        // Safe accessor for each arm
        var caseFields = type.Members.OfType<FieldDeclarationSyntax>()
            .Where(f => f.AttributeLists.SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString().Contains("Case")));
        
        foreach (var caseField in caseFields)
        {
            var armType = caseField.Declaration.Type.ToString();
            var armName = caseField.Declaration.Variables.First().Identifier.Text;
            
            // Get case value from attribute
            var caseAttr = caseField.AttributeLists.SelectMany(al => al.Attributes)
                .First(attr => attr.Name.ToString().Contains("DdsCase"));
            var caseValue = caseAttr.ArgumentList?.Arguments.FirstOrDefault()?.ToString() ?? "0";
            
            EmitLine($"    public {armType}? Try{armName}()");
            EmitLine("    {");
            EmitLine($"        if (_native.{discName} == {caseValue})");
            EmitLine($"            return _native.{armName};");
            EmitLine("        return null;");
            EmitLine("    }");
            EmitLine();
        }
        
        EmitLine("}");
        
        return _sb.ToString();
    }

    private void EmitManagedProperty(FieldDeclarationSyntax field)
    {
        var fieldType = field.Declaration.Type.ToString();
        var fieldName = field.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "unknown";
        
        // Primitives: direct access
        if (fieldType is "byte" or "sbyte" or "short" or "ushort" or 
                       "int" or "uint" or "long" or "ulong" or 
                       "float" or "double" or "bool")
        {
            EmitLine($"    public {fieldType} {fieldName} => _native.{fieldName};");
            EmitLine();
            return;
        }
        
        // FixedString: ReadOnlySpan<byte>
        if (fieldType.StartsWith("FixedString"))
        {
            EmitLine($"    public unsafe ReadOnlySpan<byte> {fieldName}");
            EmitLine("    {");
            EmitLine("        get");
            EmitLine("        {");
            EmitLine($"            fixed (byte* ptr = _native.{fieldName})");
            EmitLine("            {");
            var size = fieldType switch {
                "FixedString32" => 32,
                "FixedString64" => 64,
                "FixedString128" => 128,
                _ => 32
            };
            EmitLine($"                return new ReadOnlySpan<byte>(ptr, {size});");
            EmitLine("            }");
            EmitLine("        }");
            EmitLine("    }");
            EmitLine();
            return;
        }
        
        // Guid: return as Guid
        if (fieldType is "Guid" or "System.Guid")
        {
            EmitLine($"    public unsafe Guid {fieldName}");
            EmitLine("    {");
            EmitLine("        get");
            EmitLine("        {");
            EmitLine($"            fixed (byte* ptr = _native.{fieldName})");
            EmitLine("            {");
            EmitLine("                return *(Guid*)ptr;");
            EmitLine("            }");
            EmitLine("        }");
            EmitLine("    }");
            EmitLine();
            return;
        }
        
        // DateTime: return as DateTime
        if (fieldType is "DateTime" or "System.DateTime")
        {
            EmitLine($"    public DateTime {fieldName} => new DateTime(_native.{fieldName});");
            EmitLine();
            return;
        }
        
        // TODO: Handle string (unbounded), arrays, nested types
        // For now, skip
    }
    
    private void EmitLine(string text = "")
    {
        _sb.AppendLine(text);
    }
}
