using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace CycloneDDS.CodeGen
{
    public class IdlEmitter
    {
        public string EmitIdl(TypeInfo type)
        {
            var sb = new StringBuilder();
            
            // Header
            sb.AppendLine("// Auto-generated by CycloneDDS.CodeGen");
            
            // Includes
            var dependencies = GetDependencies(type);
            foreach (var dep in dependencies)
            {
                sb.AppendLine($"#include \"{dep}.idl\"");
            }
            sb.AppendLine();
            
            // Module (namespace)
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                sb.AppendLine($"module {type.Namespace.Replace('.', '_')} {{");
                sb.AppendLine();
            }
            
            // Type definition
            if (type.IsEnum)
            {
                EmitEnum(sb, type);
            }
            else if (type.HasAttribute("DdsUnion"))
            {
                EmitUnion(sb, type);
            }
            else
            {
                EmitStruct(sb, type);
            }
            
            // Close module
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                sb.AppendLine("}; // module");
            }
            
            return sb.ToString();
        }
        
        private void EmitStruct(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine("@appendable");
            sb.AppendLine($"struct {type.Name} {{");
            
            foreach (var field in type.Fields)
            {
                var (idlType, suffix) = MapType(field);
                string annotations = "";
                
                if (field.HasAttribute("DdsKey"))
                    annotations = "@key ";
                
                if (field.HasAttribute("DdsOptional"))
                    annotations += "@optional ";
                
                sb.AppendLine($"    {annotations}{idlType} {ToCamelCase(field.Name)}{suffix};");
            }
            
            sb.AppendLine("};");
        }

        private void EmitUnion(StringBuilder sb, TypeInfo type)
        {
            // Find discriminator type
            var discriminator = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDiscriminator"));
            if (discriminator == null) throw new InvalidOperationException("Union must have a discriminator");

            var (switchType, _) = MapType(discriminator);

            sb.AppendLine("@appendable");
            sb.AppendLine($"union {type.Name} switch ({switchType}) {{");

            foreach (var field in type.Fields)
            {
                if (field == discriminator) continue;

                var caseAttr = field.GetAttribute("DdsCase");
                if (caseAttr != null)
                {
                    foreach (var val in caseAttr.CaseValues)
                    {
                        sb.AppendLine($"    case {val}:");
                    }
                    var (idlType, suffix) = MapType(field);
                    sb.AppendLine($"        {idlType} {ToCamelCase(field.Name)}{suffix};");
                }
            }

            sb.AppendLine("};");
        }
        
        private (string Type, string Suffix) MapType(FieldInfo field)
        {
            var typeName = field.TypeName;

            // Fixed Strings
            if (typeName.Contains("FixedString32")) return ("char", "[32]");
            if (typeName.Contains("FixedString64")) return ("char", "[64]");
            if (typeName.Contains("FixedString128")) return ("char", "[128]");
            if (typeName.Contains("FixedString256")) return ("char", "[256]");

            // Primitives
            if (typeName == "byte" || typeName == "System.Byte") return ("octet", "");
            if (typeName == "sbyte" || typeName == "System.SByte") return ("int8", "");
            if (typeName == "short" || typeName == "System.Int16") return ("int16", "");
            if (typeName == "ushort" || typeName == "System.UInt16") return ("uint16", "");
            if (typeName == "int" || typeName == "System.Int32") return ("int32", "");
            if (typeName == "uint" || typeName == "System.UInt32") return ("uint32", "");
            if (typeName == "long" || typeName == "System.Int64") return ("int64", "");
            if (typeName == "ulong" || typeName == "System.UInt64") return ("uint64", "");
            if (typeName == "float" || typeName == "System.Single") return ("float", "");
            if (typeName == "double" || typeName == "System.Double") return ("double", "");
            if (typeName == "bool" || typeName == "System.Boolean") return ("boolean", "");
            if (typeName == "char" || typeName == "System.Char") return ("char", "");
            
            // New Standard Types
            if (typeName == "Guid" || typeName == "System.Guid") return ("octet", "[16]");
            if (typeName == "DateTime" || typeName == "System.DateTime") return ("int64", "");
            if (typeName == "DateTimeOffset" || typeName == "System.DateTimeOffset") return ("octet", "[16]");
            if (typeName == "TimeSpan" || typeName == "System.TimeSpan") return ("int64", ""); // Ticks
            
            // System.Numerics
            if (typeName == "Vector2" || typeName == "System.Numerics.Vector2") return ("float", "[2]");
            if (typeName == "Vector3" || typeName == "System.Numerics.Vector3") return ("float", "[3]");
            if (typeName == "Vector4" || typeName == "System.Numerics.Vector4") return ("float", "[4]");
            if (typeName == "Quaternion" || typeName == "System.Numerics.Quaternion") return ("float", "[4]");
            if (typeName == "Matrix4x4" || typeName == "System.Numerics.Matrix4x4") return ("float", "[16]");

            // Arrays
            if (typeName.EndsWith("[]"))
            {
                var elementTypeName = typeName.Substring(0, typeName.Length - 2);
                var innerField = new FieldInfo { TypeName = elementTypeName };
                var (innerIdl, innerSuffix) = MapType(innerField);
                return ($"sequence<{innerIdl}>", "");
            }

            // BoundedSeq
            if (typeName.Contains("BoundedSeq<"))
            {
                // Extract T
                var start = typeName.IndexOf('<') + 1;
                var end = typeName.LastIndexOf('>');
                var innerType = typeName.Substring(start, end - start);
                
                // Recursively map inner type
                // We create a dummy FieldInfo for the inner type
                var innerField = new FieldInfo { TypeName = innerType };
                // Pass resolved type if available? 
                // We don't have resolved type for inner generic arg easily here without more parsing.
                // But MapType handles simple names too.
                
                var (innerIdl, innerSuffix) = MapType(innerField);
                // Sequence of array? sequence<char[32]> is not valid IDL?
                // IDL: sequence<type, bound>
                // If inner type has suffix (array), we might need a typedef.
                // But for now let's assume simple sequences.
                
                return ($"sequence<{innerIdl}>", "");
            }

            // Managed String
            if (typeName == "string" || typeName == "System.String") return ("string", "");

            // Nested types
            if (field.Type != null)
            {
                return (field.Type.Name, "");
            }
            
            // Fallback to simple name (e.g. Enums)
            var parts = typeName.Split('.');
            return (parts.Last(), "");
        }

        private void EmitEnum(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"enum {type.Name} {{");
            for (int i = 0; i < type.EnumMembers.Count; i++)
            {
                var member = type.EnumMembers[i];
                sb.AppendLine($"    {member}{(i < type.EnumMembers.Count - 1 ? "," : "")}");
            }
            sb.AppendLine("};");
        }

        private HashSet<string> GetDependencies(TypeInfo type)
        {
            var deps = new HashSet<string>();
            foreach (var field in type.Fields)
            {
                if (field.Type != null)
                {
                    // Avoid self-include
                    if (field.Type.Name != type.Name)
                    {
                        deps.Add(field.Type.Name);
                    }
                }
                else if (field.TypeName.Contains("BoundedSeq<"))
                {
                    // Check inner type of sequence?
                    // We don't have resolved inner type easily here.
                    // But if we did, we should add it.
                    // For now, assume simple types or we need to improve resolution.
                }
            }
            return deps;
        }

        private string ToCamelCase(string name)
        {
            if (string.IsNullOrEmpty(name)) return name;
            return char.ToLowerInvariant(name[0]) + name.Substring(1);
        }
    }
}
