using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using CycloneDDS.CodeGen.IdlJson;

namespace CycloneDDS.CodeGen
{
    /// <summary>
    /// Parser for JSON output from 'idlc -l json' command.
    /// Replaces the fragile CppAst-based DescriptorParser with clean JSON deserialization.
    /// </summary>
    public class IdlJsonParser
    {
        private readonly JsonSerializerOptions _jsonOptions;

        public IdlJsonParser()
        {
            _jsonOptions = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                AllowTrailingCommas = true, // Handle _eof workaround in JSON
                ReadCommentHandling = JsonCommentHandling.Skip
            };
        }

        /// <summary>
        /// Parse a JSON file generated by 'idlc -l json' and extract type definitions.
        /// </summary>
        /// <param name="jsonFilePath">Path to the .json file</param>
        /// <returns>List of type definitions with topic descriptors</returns>
        /// <exception cref="FileNotFoundException">If JSON file doesn't exist</exception>
        /// <exception cref="InvalidOperationException">If JSON parsing fails</exception>
        public List<JsonTypeDefinition> Parse(string jsonFilePath)
        {
            if (string.IsNullOrWhiteSpace(jsonFilePath))
            {
                throw new ArgumentException("JSON file path cannot be empty", nameof(jsonFilePath));
            }

            if (!File.Exists(jsonFilePath))
            {
                throw new FileNotFoundException($"IDL JSON file not found: {jsonFilePath}");
            }

            try
            {
                string jsonContent = File.ReadAllText(jsonFilePath);
                return ParseJson(jsonContent);
            }
            catch (IOException ex)
            {
                throw new InvalidOperationException($"Failed to read JSON file '{jsonFilePath}': {ex.Message}", ex);
            }
        }

        /// <summary>
        /// Parse JSON content string (useful for testing)
        /// </summary>
        /// <param name="jsonContent">JSON content as string</param>
        /// <returns>List of type definitions</returns>
        public List<JsonTypeDefinition> ParseJson(string jsonContent)
        {
            if (string.IsNullOrWhiteSpace(jsonContent))
            {
                return new List<JsonTypeDefinition>();
            }

            try
            {
                var root = JsonSerializer.Deserialize<IdlJsonRoot>(jsonContent, _jsonOptions);
                
                if (root == null)
                {
                    throw new InvalidOperationException("JSON deserialization returned null");
                }

                return root.Types ?? new List<JsonTypeDefinition>();
            }
            catch (JsonException ex)
            {
                throw new InvalidOperationException(
                    $"Failed to parse IDL JSON output. Ensure 'idlc -l json' generated valid JSON. Error: {ex.Message}", 
                    ex);
            }
        }

        /// <summary>
        /// Find a type definition by name (supports both C# and IDL naming)
        /// </summary>
        /// <param name="types">List of type definitions</param>
        /// <param name="typeName">Type name to search for (supports "Namespace.Type" or "Namespace::Type")</param>
        /// <returns>Type definition if found, null otherwise</returns>
        public JsonTypeDefinition? FindType(List<JsonTypeDefinition> types, string typeName)
        {
            if (types == null || string.IsNullOrWhiteSpace(typeName))
            {
                return null;
            }

            // Try exact match first
            var exactMatch = types.Find(t => t.Name == typeName);
            if (exactMatch != null)
            {
                return exactMatch;
            }

            // Try converting C# namespace syntax to IDL syntax (. -> ::)
            string idlStyleName = typeName.Replace(".", "::");
            var idlMatch = types.Find(t => t.Name == idlStyleName);
            if (idlMatch != null)
            {
                return idlMatch;
            }

            // Try converting IDL syntax to C# syntax (:: -> .)
            string csharpStyleName = typeName.Replace("::", ".");
            var csharpMatch = types.Find(t => t.Name == csharpStyleName);
            if (csharpMatch != null)
            {
                return csharpMatch;
            }

            // Try case-insensitive match as last resort
            return types.Find(t => string.Equals(t.Name, typeName, StringComparison.OrdinalIgnoreCase) ||
                                   string.Equals(t.Name, idlStyleName, StringComparison.OrdinalIgnoreCase) ||
                                   string.Equals(t.Name, csharpStyleName, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Extract all types that have topic descriptors
        /// </summary>
        /// <param name="types">List of type definitions</param>
        /// <returns>Types with topic descriptors</returns>
        public List<JsonTypeDefinition> GetTopicTypes(List<JsonTypeDefinition> types)
        {
            if (types == null)
            {
                return new List<JsonTypeDefinition>();
            }

            return types.FindAll(t => t.TopicDescriptor != null);
        }

        /// <summary>
        /// Validate that a type definition has all required fields for descriptor generation
        /// </summary>
        public bool IsValidTopicType(JsonTypeDefinition type)
        {
            if (type == null)
            {
                return false;
            }

            // Must have a topic descriptor
            if (type.TopicDescriptor == null)
            {
                return false;
            }

            var desc = type.TopicDescriptor;

            // Must have ops array
            if (desc.Ops == null || desc.Ops.Length == 0)
            {
                return false;
            }

            // Keys are optional (keyless topics are valid)
            // But if keys exist, they must have valid data
            if (desc.Keys != null)
            {
                foreach (var key in desc.Keys)
                {
                    if (string.IsNullOrWhiteSpace(key.Name))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}
