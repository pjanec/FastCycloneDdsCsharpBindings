using CppAst;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace CycloneDDS.CodeGen.OffsetGeneration;

public static class AbiOffsetGenerator
{
    public static void GenerateFromSource(string cycloneSourcePath, string outputPath)
    {
        var headerPath = Path.Combine(cycloneSourcePath, 
            "src/core/ddsc/include/dds/ddsc/dds_public_impl.h");
        
        if (!File.Exists(headerPath))
            throw new FileNotFoundException($"Cyclone header not found: {headerPath}");
        
        var options = new CppParserOptions();
        options.IncludeFolders.Add(Path.Combine(cycloneSourcePath, "src/core/ddsc/include"));
        options.IncludeFolders.Add(Path.Combine(cycloneSourcePath, "src/ddsrt/include"));
        
        // Mock dds/export.h which is usually generated by CMake
        var tempInclude = Path.Combine(Path.GetTempPath(), "cyclone_mock_includes_" + Guid.NewGuid());
        var ddsDir = Path.Combine(tempInclude, "dds");
        Directory.CreateDirectory(ddsDir);
        File.WriteAllText(Path.Combine(ddsDir, "export.h"), "#define DDS_EXPORT\n");
        File.WriteAllText(Path.Combine(ddsDir, "features.h"), "#ifndef DDS_FEATURES_H\n#define DDS_FEATURES_H\n#endif\n");
        options.IncludeFolders.Add(tempInclude);

        var compilation = CppParser.ParseFile(headerPath, options);
        
        if (compilation.HasErrors)
        {
            var errors = string.Join("\n", compilation.Diagnostics.Messages);
            throw new Exception($"Failed to parse Cyclone headers:\n{errors}");
        }
        
        // Find dds_topic_descriptor_t
        var descriptorStruct = compilation.Classes
            .FirstOrDefault(c => c.Name == "dds_topic_descriptor_t" || c.Name == "dds_topic_descriptor");
        
        if (descriptorStruct == null)
        {
            // Debugging: list all classes
            // var classes = string.Join(", ", compilation.Classes.Select(c => c.Name));
            // throw new Exception($"Could not find dds_topic_descriptor_t in headers. Available: {classes}");
            throw new Exception("Could not find dds_topic_descriptor_t in headers");
        }
        
        // Extract version
        var version = ExtractCycloneVersion(cycloneSourcePath);
        
        // Generate C# code
        var code = GenerateCode(descriptorStruct, version);
        
        File.WriteAllText(outputPath, code);
        Console.WriteLine($"Generated ABI offsets for Cyclone DDS {version}");
        Console.WriteLine($"  Struct size: {descriptorStruct.SizeOf} bytes");
        Console.WriteLine($"  Output: {outputPath}");
    }
    
    private static string GenerateCode(CppClass descriptorStruct, string version)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated from Cyclone DDS source>");
        sb.AppendLine($"// Cyclone DDS Version: {version}");
        sb.AppendLine($"// Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine();
        sb.AppendLine("namespace CycloneDDS.Runtime.Descriptors;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// ABI offsets for dds_topic_descriptor_t.");
        sb.AppendLine("/// Auto-generated from Cyclone DDS source code.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class AbiOffsets");
        sb.AppendLine("{");
        sb.AppendLine($"    public const string CycloneVersion = \"{version}\";");
        sb.AppendLine();
        
        // Map C field names to C# friendly names
        var fieldMap = new Dictionary<string, string>
        {
            { "m_size", "Size" },
            { "m_align", "Align" },
            { "m_flagset", "Flagset" },
            { "m_nkeys", "NKeys" },
            { "m_typename", "TypeName" },
            { "m_keys", "Keys" },
            { "m_nops", "NOps" },
            { "m_ops", "Ops" },
            { "m_meta", "Meta" },
            { "type_information", "TypeInfo" },
            { "type_mapping", "TypeMap" }
        };
        
        foreach (var field in descriptorStruct.Fields)
        {
            if (fieldMap.TryGetValue(field.Name, out var csName))
            {
                sb.AppendLine($"    public const int {csName} = {field.Offset};");
                
                // For nested structs (type_information, type_mapping)
                // They have structure: { unsigned char* data; uint32_t sz; }
                if (field.Name == "type_information" || field.Name == "type_mapping")
                {
                    sb.AppendLine($"    public const int {csName}_Data = {field.Offset};");
                    // Pointer size depends on platform (8 on x64, 4 on x86)
                    // CppAst should give us the correct offset
                    if (field.Type is CppClass nestedStruct)
                    {
                         var szField = nestedStruct.Fields.FirstOrDefault(f => f.Name == "sz");
                         if (szField != null)
                            sb.AppendLine($"    public const int {csName}_Size = {field.Offset + szField.Offset};");
                    }
                }
            }
        }
        
        sb.AppendLine();
        sb.AppendLine($"    public const int DescriptorSize = {descriptorStruct.SizeOf};");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    private static string ExtractCycloneVersion(string sourcePath)
    {
        // Try VERSION file
        var versionFile = Path.Combine(sourcePath, "VERSION");
        if (File.Exists(versionFile))
            return File.ReadAllText(versionFile).Trim();
        
        // Try CMakeLists.txt
        var cmakePath = Path.Combine(sourcePath, "CMakeLists.txt");
        if (File.Exists(cmakePath))
        {
            var cmake = File.ReadAllText(cmakePath);
            var match = Regex.Match(cmake, @"project\([^)]*VERSION\s+([\d.]+)");
            if (match.Success)
                return match.Groups[1].Value;
        }
        
        return "unknown";
    }
}
