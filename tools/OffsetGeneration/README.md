# ABI Offset Generation

**Purpose:** Extract struct field offsets from Cyclone DDS headers for C#/native interop.

**Method:** CppAst (libclang-based C parser) compiles headers and provides ABI information.

---

## How It Actually Works

### 1. The Problem

C# needs to know **exact byte offsets** of fields in `dds_topic_descriptor_t` to write  
native memory correctly.

**Example:**
```c
// In Cyclone DDS (C):
struct dds_topic_descriptor_t {
    uint32_t m_size;      // offset: 0
    uint32_t m_align;     // offset: 4
    uint32_t m_flagset;   // offset: 8
    uint32_t m_nkeys;     // offset: 12
    char* m_typename;     // offset: 16 (64-bit), varies by platform!
    // ... more fields
};
```

**BUT:** Offsets depend on:
- Platform (x64 vs x86 vs ARM)
- Compiler (MSVC vs GCC vs Clang)
- Struct packing (`#pragma pack`, alignment rules)

**Solution:** Use a C compiler to compute offsets, extract them for C#.

---

### 2. The Method: CppAst + libclang

**CppAst** is a .NET library wrapping **libclang** (LLVM's C/C++ parser).

**What it does:**
1. **Parses C headers** (respects #include, #define, #pragma)
2. **Compiles to AST** (Abstract Syntax Tree) in-memory
3. **Applies ABI rules** (alignment, padding, packing)
4. **Exposes struct metadata** (field offsets, struct size)

**Code** (`AbiOffsetGenerator.cs` lines 34-47):
```csharp
var compilation = CppParser.ParseFile(headerPath, options);

var descriptorStruct = compilation.Classes
    .FirstOrDefault(c => c.Name == "dds_topic_descriptor_t");

foreach (var field in descriptorStruct.Fields)
{
    // CppAst computed this by compiling the header!
    int offset = field.Offset;  
    sb.AppendLine($"public const int {csName} = {offset};");
}

int structSize = descriptorStruct.SizeOf; // Also from compiler
```

**Key Point:** `field.Offset` comes from **libclang's compiled AST**, not guesswork!

---

### 3. Why This Is Reliable

#### ✅ Uses Actual Compiler Logic
- libclang is the **same frontend** used by Clang C compiler
- Computes offsets using **real ABI rules** (not hardcoded tables)
- Handles platform-specific alignment (x64: 8-byte, x86: 4-byte)

#### ✅ Respects struct packing
```c
#pragma pack(push, 1)
struct Packed { uint32_t a; uint64_t b; }; // b at offset 4
#pragma pack(pop)

struct Normal { uint32_t a; uint64_t b; };  // b at offset 8 (aligned)
```
CppAst computes BOTH correctly (unlike manual calculations).

#### ✅ Processes Macros
```c
#ifdef _WIN64
    #define ALIGN 8
#else
    #define ALIGN 4
#endif

struct S { char pad[ALIGN]; uint32_t x; };
```
CppAst expands `ALIGN` based on target platform → correct offset for `x`.

---

### 4. Verification

**Generated output** (AbiOffsets.g.cs):
```csharp
public const int Size = 0;        // offsetof(dds_topic_descriptor_t, m_size)
public const int Align = 4;       // offsetof(..                     , m_align)
public const int TypeName = 16;   // offsetof(..                     , m_typename)
public const int DescriptorSize = 96; // sizeof(dds_topic_descriptor_t)
```

**How to verify:**
1. **Compile Cyclone DDS** with same toolchain (MSVC x64)
2. **Run C program:**
   ```c
   #include <stdio.h>
   #include "dds/ddsc/dds_public_impl.h"
   int main() {
       printf("Size: %zu\n", offsetof(dds_topic_descriptor_t, m_size));
       printf("Align: %zu\n", offsetof(dds_topic_descriptor_t, m_align));
       printf("Total: %zu\n", sizeof(dds_topic_descriptor_t));
   }
   ```
3. **Compare output** with AbiOffsets.g.cs

**Result:** Values match EXACTLY (verified for Cyclone DDS 0.11.0, x64 Windows).

---

## Implementation Details

### Mock Headers for CMake Dependencies

**Problem:** Cyclone DDS headers include CMake-generated files:
```c
#include <dds/export.h>     // Generated by CMake
#include <dds/features.h>   // Generated by CMake
```

**Solution** (`AbiOffsetGenerator.cs` lines 25-31):
```csharp
// Create temporary mock headers
var tempInclude = Path.Combine(Path.GetTempPath(), "cyclone_mock_includes_" + Guid.NewGuid());
Directory.CreateDirectory(Path.Combine(tempInclude, "dds"));
File.WriteAllText(Path.Combine(tempInclude, "dds/export.h"), "#define DDS_EXPORT\n");
File.WriteAllText(Path.Combine(tempInclude, "dds/features.h"), "/* empty */\n");

options.IncludeFolders.Add(tempInclude); // CppAst finds these first
```

**Why this works:**
- `export.h` contains only `DLL_EXPORT` macros (not needed for offset calculation)
- `features.h` contains feature flags (don't affect struct layout)
- Mock versions are sufficient for libclang to parse successfully

---

## Limitations & Edge Cases

### ❌ Cannot Handle:
- **Conditional compilation** targeting different platforms (manual choice needed)
  ```c
  #ifdef __ARM__
      uint64_t arm_field;
  #else
      uint32_t x86_field;
  #endif
  ```
  CppAst picks ONE configuration.

- **Runtime-determined sizes** (e.g., `sizeof(void*)` changes at runtime)  
  Offsets are **compile-time constants** for a single platform.

### ✅ Can Handle:
- Nested structs
- Bitfields (libclang knows packing rules)
- Unions (reports largest member)
- Forward declarations (resolves via includes)
- Complex macro expansions

---

## Alternatives Considered

### Option A: Manual Offset Table
```csharp
// For x64:
public const int TypeName = 16;
// For x86:
public const int TypeName = 12;
```

**Rejected:** Error-prone, breaks when Cyclone updates.

### Option B: P/Invoke to C program
Compile C program returning offsets, P/Invoke to get them.

**Rejected:** Requires C compiler in build chain.

### Option C: Reflection on Loaded Assembly
Load compiled Cyclone DLL, use reflection.

**Rejected:** Doesn't give field offsets, only method signatures.

### Option D: CppAst ✅ CHOSEN
- No C compiler at runtime
- Portable (works on Windows/Linux/macOS)
- Accurate (uses real compiler)

---

## Future Work

### Multi-Platform Support
Generate offsets for multiple platforms:
```csharp
#if X64
    public const int TypeName = 16;
#elif X86
    public const int TypeName = 12;
#endif
```

**How:** Run CppAst with different platform defines, merge outputs.

### Runtime Validation
Add startup check:
```csharp
static AbiOffsets() {
    // Load actual ddsc.dll, verify struct size matches
    if (GetActualDescriptorSize() != DescriptorSize)
        throw new Exception("ABI mismatch!");
}
```

---

## References

- **CppAst:** https://github.com/xoofx/CppAst
- **libclang:** https://clang.llvm.org/doxygen/group__CINDEX.html
- **Cyclone DDS:** https://github.com/eclipse-cyclonedds/cyclonedds
- **C ABI:** https://en.wikipedia.org/wiki/Application_binary_interface

---

**Bottom Line:** Offsets come from a REAL C compiler (libclang), not guesswork. This is as reliable as compiling C code.
