module Verification {
    // ========== ENUMS ==========
    enum Color { RED, GREEN, BLUE, YELLOW };
    enum Status { PENDING, ACTIVE, SUSPENDED, TERMINATED };
    enum Priority { LOW, MEDIUM, HIGH, CRITICAL };
    
    // ========== BASIC STRUCTS ==========
    struct Point2D {
        double x;
        double y;
    };

    struct Point3D {
        double x;
        double y;
        double z;
    };

    struct NestedStruct {
        char c;
        long l;
        short s;
    };

    // ========== UNIONS ==========
    union Shape switch(long) {
        case 1: Point2D p2d;
        case 2: Point3D p3d;
        case 3: long radius;
    };

    union Value switch(boolean) {
        case TRUE: double dbl;
        case FALSE: string str;
    };

    union IntUnion switch(short) {
        case 1: octet byte_val;
        case 2: short short_val;
        case 3: long long_val;
    };

    // ========== TEST TOPIC 1: All Primitive Types ==========
    @topic
    struct AllPrimitives {
        @key long id;
        boolean bool_field;
        char char_field;
        octet octet_field;
        short short_field;
        unsigned short ushort_field;
        long long_field;
        unsigned long ulong_field;
        long long llong_field;
        unsigned long long ullong_field;
        float float_field;
        double double_field;
    };

    // ========== TEST TOPIC 2: Composite Key ==========
    @topic
    struct CompositeKey {
        @key string<32> region;
        @key long zone;
        @key short sector;
        string<64> name;
        double value;
    };

    // ========== TEST TOPIC 3: Nested Key ==========
    struct Location {
        @key long building;
        @key short floor;
        long room;
    };

    @topic
    struct NestedKeyTopic {
        @key Location location;
        string<128> description;
        double temperature;
    };

    // ========== TEST TOPIC 4: Sequences ==========
    typedef string<16> BoundedString16;
    
    @topic
    struct SequenceTopic {
        @key long id;
        sequence<long> unbounded_seq;
        sequence<long, 10> bounded_seq;
        sequence<double> double_seq;
        sequence<BoundedString16> string_seq;
    };

    // ========== TEST TOPIC 5: Nested Sequences ==========
    typedef sequence<long> LongSeq;
    typedef sequence<double, 5> BoundedDoubleSeq;
    
    @topic
    struct NestedSequences {
        @key long id;
        sequence<LongSeq> matrix;
        sequence<BoundedDoubleSeq, 10> bounded_matrix;
    };

    // ========== TEST TOPIC 6: Arrays ==========
    @topic
    struct ArrayTopic {
        @key long id;
        long array_1d[10];
        double array_2d[3][3];
        short array_3d[2][3][4];
        char char_array[20];
    };

    // ========== TEST TOPIC 7: Strings ==========
    @topic
    struct StringTopic {
        @key string<32> key_str;
        string unbounded_str;
        string<64> bounded_str;
        string<128> description;
    };

    // ========== TEST TOPIC 8: Optional Fields ==========
    @topic
    struct OptionalFields {
        @key long id;
        @optional long opt_long;
        @optional double opt_double;
        @optional string<64> opt_string;
        @optional NestedStruct opt_struct;
    };

    // ========== TEST TOPIC 9: Mixed Content ==========
    @topic
    struct MixedContent {
        @key long id;
        Color primary_color;
        NestedStruct details;
        Shape geometry;
        sequence<long> history;
        string<64> description;
        long matrix[2][2];
    };

    // ========== TEST TOPIC 10: Union Topic ==========
    @topic
    struct UnionTopic {
        @key long id;
        Shape shape_val;
        Value generic_val;
        IntUnion int_val;
    };

    // ========== TYPEDEFS & ALIASES ==========
    typedef long MyLong;
    typedef MyLong Age;
    typedef Age AgeArray[10];

    @topic
    struct TypedefStruct {
        @key MyLong id;
        Age age;
        AgeArray recent_ages;
    };
};

module RoundtripTests {
    enum Priority { 
        LOW, 
        MEDIUM, 
        HIGH, 
        CRITICAL 
    };
    
    struct Timestamp {
        long long seconds;
        unsigned long nanoseconds;
    };

    struct Location {
        @key long building;
        @key short floor;
        long room;
    };
    
    @topic
    struct AllPrimitives {
        @key long id;
        boolean bool_field;
        char char_field;
        octet octet_field;
        short short_field;
        unsigned short ushort_field;
        long long_field;
        unsigned long ulong_field;
        long long llong_field;
        unsigned long long ullong_field;
        float float_field;
        double double_field;
    };

    @topic
    @appendable
    struct CompositeKey {
        @key string<32> region;
        @key long zone;
        @key short sector;
        
        string<64> name;
        double value;
        Priority priority;
    };

    @topic
    @appendable
    struct NestedKeyTopic {
        @key Location location;
        
        string<128> description;
        double temperature;
        Timestamp last_updated;
    };
};
// ============================================================================
// C# to C Atomic Test Topics - Minimalistic DDS Interoperability Testing
// ============================================================================
// This IDL file contains MINIMALISTIC test topics designed to test each
// DDS feature in isolation. Each topic tests exactly ONE concept.
//
// Design Philosophy:
// - Start from the simplest primitives
// - Build up complexity incrementally
// - One feature per topic
// - Easy to debug when something fails
//
// Testing Strategy:
// 1. All topics must pass IdlJson.Tests verification first
// 2. Native C sends deterministic data from seed
// 3. C# receives, deserializes, and validates
// 4. C# captures CDR byte stream for reference
// 5. C# serializes and compares to native CDR
// 6. C# sends back to native for final validation
// ============================================================================

module AtomicTests {
    
    // ========================================================================
    // SECTION 1: BASIC PRIMITIVES (Single Field Each)
    // ========================================================================
    // Each topic tests serialization/deserialization of ONE primitive type.
    // Key is always 'id' to keep it simple and consistent.
    // ========================================================================
    
    @topic
    struct BooleanTopic {
        @key long id;
        boolean value;
    };
    
    @topic
    struct CharTopic {
        @key long id;
        char value;
    };
    
    @topic
    struct OctetTopic {
        @key long id;
        octet value;
    };
    
    @topic
    struct Int16Topic {
        @key long id;
        short value;
    };
    
    @topic
    struct UInt16Topic {
        @key long id;
        unsigned short value;
    };
    
    @topic
    struct Int32Topic {
        @key long id;
        long value;
    };
    
    @topic
    struct UInt32Topic {
        @key long id;
        unsigned long value;
    };
    
    @topic
    struct Int64Topic {
        @key long id;
        long long value;
    };
    
    @topic
    struct UInt64Topic {
        @key long id;
        unsigned long long value;
    };
    
    @topic
    struct Float32Topic {
        @key long id;
        float value;
    };
    
    @topic
    struct Float64Topic {
        @key long id;
        double value;
    };
    
    @topic
    struct StringUnboundedTopic {
        @key long id;
        string value;
    };
    
    @topic
    struct StringBounded32Topic {
        @key long id;
        string<32> value;
    };
    
    @topic
    struct StringBounded256Topic {
        @key long id;
        string<256> value;
    };
    
    // ========================================================================
    // SECTION 2: ENUMERATIONS
    // ========================================================================
    
    enum SimpleEnum { 
        FIRST, 
        SECOND, 
        THIRD 
    };
    
    @topic
    struct EnumTopic {
        @key long id;
        SimpleEnum value;
    };
    
    enum ColorEnum { 
        RED, 
        GREEN, 
        BLUE, 
        YELLOW, 
        MAGENTA, 
        CYAN 
    };
    
    @topic
    struct ColorEnumTopic {
        @key long id;
        ColorEnum color;
    };
    
    // ========================================================================
    // SECTION 3: NESTED STRUCTURES
    // ========================================================================
    
    struct Point2D {
        double x;
        double y;
    };
    
    @topic
    struct NestedStructTopic {
        @key long id;
        Point2D point;
    };
    
    struct Point3D {
        double x;
        double y;
        double z;
    };
    
    @topic
    struct Nested3DTopic {
        @key long id;
        Point3D point;
    };
    
    struct Box {
        Point2D topLeft;
        Point2D bottomRight;
    };
    
    @topic
    struct DoublyNestedTopic {
        @key long id;
        Box box;
    };
    
    struct Container {
        long count;
        Point3D center;
        double radius;
    };
    
    @topic
    struct ComplexNestedTopic {
        @key long id;
        Container container;
    };
    
    // ========================================================================
    // SECTION 4: UNIONS
    // ========================================================================
    
    // Union with long discriminator
    union SimpleUnion switch(long) {
        case 1: long int_value;
        case 2: double double_value;
        case 3: string<64> string_value;
    };
    
    @topic
    struct UnionLongDiscTopic {
        @key long id;
        SimpleUnion data;
    };
    
    // Union with boolean discriminator
    union BoolUnion switch(boolean) {
        case TRUE: long true_val;
        case FALSE: double false_val;
    };
    
    @topic
    struct UnionBoolDiscTopic {
        @key long id;
        BoolUnion data;
    };
    
    // Union with enum discriminator
    union ColorUnion switch(ColorEnum) {
        case RED: long red_data;
        case GREEN: double green_data;
        case BLUE: string<32> blue_data;
        case YELLOW: Point2D yellow_point;
    };
    
    @topic
    struct UnionEnumDiscTopic {
        @key long id;
        ColorUnion data;
    };
    
    // Union with short discriminator
    union ShortUnion switch(short) {
        case 1: octet byte_val;
        case 2: short short_val;
        case 3: long long_val;
        case 4: float float_val;
    };
    
    @topic
    struct UnionShortDiscTopic {
        @key long id;
        ShortUnion data;
    };
    
    // ========================================================================
    // SECTION 5: OPTIONAL FIELDS
    // ========================================================================
    
    @topic
    struct OptionalInt32Topic {
        @key long id;
        @optional long opt_value;
    };
    
    @topic
    struct OptionalFloat64Topic {
        @key long id;
        @optional double opt_value;
    };
    
    @topic
    struct OptionalStringTopic {
        @key long id;
        @optional string<64> opt_string;
    };
    
    @topic
    struct OptionalStructTopic {
        @key long id;
        @optional Point2D opt_point;
    };
    
    @topic
    struct OptionalEnumTopic {
        @key long id;
        @optional SimpleEnum opt_enum;
    };
    
    @topic
    struct MultiOptionalTopic {
        @key long id;
        @optional long opt_int;
        @optional double opt_double;
        @optional string<32> opt_string;
    };
    
    // ========================================================================
    // SECTION 6: SIMPLE SEQUENCES
    // ========================================================================
    
    @topic
    struct SequenceInt32Topic {
        @key long id;
        sequence<long> values;
    };
    
    @topic
    struct BoundedSequenceInt32Topic {
        @key long id;
        sequence<long, 10> values;
    };
    
    @topic
    struct SequenceInt64Topic {
        @key long id;
        sequence<long long> values;
    };
    
    @topic
    struct SequenceFloat32Topic {
        @key long id;
        sequence<float> values;
    };
    
    @topic
    struct SequenceFloat64Topic {
        @key long id;
        sequence<double> values;
    };
    
    @topic
    struct SequenceBooleanTopic {
        @key long id;
        sequence<boolean> values;
    };
    
    @topic
    struct SequenceOctetTopic {
        @key long id;
        sequence<octet> bytes;
    };
    
    typedef string<32> String32;

    @topic
    struct SequenceStringTopic {
        @key long id;
        sequence<String32> values;
    };
    
    @topic
    struct SequenceEnumTopic {
        @key long id;
        sequence<SimpleEnum> values;
    };
    
    @topic
    struct SequenceStructTopic {
        @key long id;
        sequence<Point2D> points;
    };
    
    @topic
    struct SequenceUnionTopic {
        @key long id;
        sequence<SimpleUnion> unions;
    };
    
    // ========================================================================
    // SECTION 7: ARRAYS
    // ========================================================================
    
    @topic
    struct ArrayInt32Topic {
        @key long id;
        long values[5];
    };
    
    @topic
    struct ArrayFloat64Topic {
        @key long id;
        double values[5];
    };
    
    @topic
    struct ArrayStringTopic {
        @key long id;
        string<16> names[5];
    };
    
    @topic
    struct Array2DInt32Topic {
        @key long id;
        long matrix[3][4];
    };
    
    @topic
    struct Array3DInt32Topic {
        @key long id;
        long cube[2][3][4];
    };
    
    @topic
    struct ArrayStructTopic {
        @key long id;
        Point2D points[3];
    };
    
    // ========================================================================
    // SECTION 8: EXTENSIBILITY (Appendable, Final, Mutable)
    // ========================================================================
    
    @appendable
    @topic
    struct AppendableInt32Topic {
        @key long id;
        long value;
    };
    
    @appendable
    @topic
    struct AppendableStructTopic {
        @key long id;
        Point2D point;
    };
    
    @final
    @topic
    struct FinalInt32Topic {
        @key long id;
        long value;
    };
    
    @final
    @topic
    struct FinalStructTopic {
        @key long id;
        Point2D point;
    };
    
    @mutable
    @topic
    struct MutableInt32Topic {
        @key long id;
        @id(100) long value;
    };
    
    @mutable
    @topic
    struct MutableStructTopic {
        @key long id;
        @id(200) Point2D point;
    };
    
    // ========================================================================
    // SECTION 9: COMPOSITE KEYS
    // ========================================================================
    
    @topic
    struct TwoKeyInt32Topic {
        @key long key1;
        @key long key2;
        double value;
    };
    
    @topic
    struct TwoKeyStringTopic {
        @key string<32> key1;
        @key string<32> key2;
        double value;
    };
    
    @topic
    struct ThreeKeyTopic {
        @key long key1;
        @key string<32> key2;
        @key short key3;
        double value;
    };
    
    @topic
    struct FourKeyTopic {
        @key long key1;
        @key long key2;
        @key long key3;
        @key long key4;
        string<64> description;
    };
    
    // ========================================================================
    // SECTION 10: NESTED KEYS
    // ========================================================================
    
    struct Location {
        @key long building;
        @key short floor;
    };
    
    @topic
    struct NestedKeyTopic {
        @key Location loc;
        double temperature;
    };
    
    struct Coordinates {
        @key double latitude;
        @key double longitude;
    };
    
    @topic
    struct NestedKeyGeoTopic {
        @key Coordinates coords;
        string<128> location_name;
    };
    
    struct TripleKey {
        @key long id1;
        @key long id2;
        @key long id3;
    };
    
    @topic
    struct NestedTripleKeyTopic {
        @key TripleKey keys;
        string<64> data;
    };
    
    // ========================================================================
    // SECTION 11: ADVANCED COMBINATIONS (Test After Basics Pass)
    // ========================================================================
    
    // @topic
    // struct SequenceOfOptionalTopic {
    //     @key long id;
    //     sequence<@optional long> opt_values;
    // };
    
    // @topic
    // struct OptionalSequenceTopic {
    //     @key long id;
    //     @optional sequence<long> opt_sequence;
    // };
    
    // @topic
    // struct NestedSequenceTopic {
    //     @key long id;
    //     sequence<sequence<long>> matrix;
    // };
    
    // @topic
    // struct SequenceOfStructWithSequenceTopic {
    //     @key long id;
    //     sequence<Container> containers;
    // };
    
    // @appendable
    // @topic
    // struct AppendableWithSequenceTopic {
    //     @key long id;
    //     sequence<Point2D> points;
    //     @optional string<64> description;
    // };
    
    // @topic
    // struct ArrayOfSequenceTopic {
    //     @key long id;
    //     sequence<long>[3] seq_array;
    // };
    
    // @topic
    // struct ComplexKeyTopic {
    //     @key long id;
    //     @key Point2D key_point;
    //     sequence<double> measurements;
    // };
    
    // ========================================================================
    // SECTION 12: EDGE CASES
    // ========================================================================
    
    @topic
    struct EmptySequenceTopic {
        @key long id;
        sequence<long> empty_seq;  // Will test with zero elements
    };
    
    @topic
    struct LargeSequenceTopic {
        @key long id;
        sequence<long> large_seq;  // Will test with 1000+ elements
    };
    
    @topic
    struct LongStringTopic {
        @key long id;
        string<4096> long_string;
    };
    
    @topic
    struct UnboundedStringTopic {
        @key long id;
        string unbounded;  // Will test with varying sizes
    };
    
    @topic
    struct AllPrimitivesAtomicTopic {
        @key long id;
        boolean bool_val;
        char char_val;
        octet octet_val;
        short short_val;
        unsigned short ushort_val;
        long long_val;
        unsigned long ulong_val;
        long long llong_val;
        unsigned long long ullong_val;
        float float_val;
        double double_val;
    };
    
    // ========================================================================
    // ROUNDTRIP SPECIFIC APPENDABLE DUPLICATES
    // ========================================================================

    @appendable
    @topic
    struct BooleanTopicAppendable {
        @key long id;
        boolean value;
    };

    @appendable
    @topic
    struct Int32TopicAppendable {
        @key long id;
        long value;
    };

    @appendable
    @topic
    struct StringBounded32TopicAppendable {
        @key long id;
        string<32> value;
    };

    @appendable
    @topic
    struct SequenceInt32TopicAppendable {
        @key long id;
        sequence<long> values;
    };

    @appendable
    union SimpleUnionAppendable switch(long) {
        case 1: long int_value;
        case 2: double double_value;
        case 3: string string_value;
    };

    @appendable
    @topic
    struct UnionLongDiscTopicAppendable {
        @key long id;
        SimpleUnionAppendable data;
    };

    @appendable
    @topic
    struct CharTopicAppendable {
        @key long id;
        char value;
    };

    @appendable
    @topic
    struct OctetTopicAppendable {
        @key long id;
        octet value;
    };
    
    @appendable
    @topic
    struct Int16TopicAppendable {
        @key long id;
        short value;
    };
    
    @appendable
    @topic
    struct UInt16TopicAppendable {
        @key long id;
        unsigned short value;
    };
    
    @appendable
    @topic
    struct UInt32TopicAppendable {
        @key long id;
        unsigned long value;
    };
    
    @appendable
    @topic
    struct Int64TopicAppendable {
        @key long id;
        long long value;
    };
    
    @appendable
    @topic
    struct UInt64TopicAppendable {
        @key long id;
        unsigned long long value;
    };

    @appendable
    @topic
    struct Float32TopicAppendable {
        @key long id;
        float value;
    };
    
    @appendable
    @topic
    struct Float64TopicAppendable {
        @key long id;
        double value;
    };

    @appendable
    @topic
    struct StringUnboundedTopicAppendable {
        @key long id;
        string value;
    };
    
    @appendable
    @topic
    struct StringBounded256TopicAppendable {
        @key long id;
        string<256> value;
    };

    @appendable
    @topic
    struct EnumTopicAppendable {
        @key long id;
        SimpleEnum value;
    };

    @appendable
    @topic
    struct ColorEnumTopicAppendable {
        @key long id;
        ColorEnum color;
    };

    @appendable
    @topic
    struct ArrayInt32TopicAppendable {
        @key long id;
        long values[5];
    };
    
    @appendable
    @topic
    struct ArrayFloat64TopicAppendable {
        @key long id;
        double values[5];
    };
    
    @appendable
    @topic
    struct ArrayStringTopicAppendable {
        @key long id;
        string<16> names[5];
    };

    @appendable
    @topic
    struct Array2DInt32TopicAppendable {
        @key long id;
        long matrix[3][4];
    };

    @appendable
    @topic
    struct Array3DInt32TopicAppendable {
        @key long id;
        long cube[2][3][4];
    };

    @appendable
    @topic
    struct ArrayStructTopicAppendable {
        @key long id;
        AtomicTests::Point2D points[3];
    };

};
