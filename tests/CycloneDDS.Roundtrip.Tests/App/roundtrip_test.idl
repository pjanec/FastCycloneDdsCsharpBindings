// ============================================================================
// Roundtrip Test Messages - Comprehensive DDS Interoperability Testing
// ============================================================================
// This IDL file contains complex message types designed to thoroughly test
// serialization/deserialization between C# bindings and native C implementation.
//
// Coverage:
// - All primitive types
// - Sequences (bounded/unbounded, nested)
// - Arrays (single/multi-dimensional)
// - Unions (various discriminator types)
// - Nested structures
// - Composite keys, nested keys
// - Strings (bounded/unbounded)
// - Enums
// - Typedefs and aliases
// ============================================================================

module RoundtripTests {
    
    // ========================================
    // Enumerations
    // ========================================
    
    enum Color { 
        RED, 
        GREEN, 
        BLUE, 
        YELLOW 
    };
    
    enum Status { 
        PENDING, 
        ACTIVE, 
        SUSPENDED, 
        TERMINATED 
    };
    
    enum Priority { 
        LOW, 
        MEDIUM, 
        HIGH, 
        CRITICAL 
    };
    
    // ========================================
    // Basic Structures
    // ========================================
    
    struct Point2D {
        double x;
        double y;
    };

    struct Point3D {
        double x;
        double y;
        double z;
    };

    struct Timestamp {
        long long seconds;
        unsigned long nanoseconds;
    };
    
    // ========================================
    // Unions
    // ========================================
    
    // Union with integer discriminator
    union Shape switch(long) {
        case 1: Point2D point2d;
        case 2: Point3D point3d;
        case 3: long radius;
        default: string<64> description;
    };
    
    // Union with boolean discriminator
    union Value switch(boolean) {
        case TRUE: double number;
        case FALSE: string<128> text;
    };
    
    // Union with enum discriminator
    union ColoredValue switch(Color) {
        case RED: long red_value;
        case GREEN: double green_value;
        case BLUE: string<32> blue_value;
        case YELLOW: Point2D yellow_point;
    };
    
    // ========================================
    // TEST 1: All Primitive Types
    // ========================================
    
    @topic
    struct AllPrimitives {
        @key long id;
        
        // Booleans
        boolean bool_field;
        
        // Characters
        char char_field;
        
        // Integers
        octet octet_field;
        short short_field;
        unsigned short ushort_field;
        long long_field;
        unsigned long ulong_field;
        long long llong_field;
        unsigned long long ullong_field;
        
        // Floating-point
        float float_field;
        double double_field;
    };
    
    // ========================================
    // TEST 2: Composite Key
    // ========================================
    
    @topic
    @final
    struct CompositeKey {
        @key string<32> region;
        @key long zone;
        @key short sector;
        
        string<64> name;
        double value;
        Priority priority;
    };
    
    // ========================================
    // TEST 3: Nested Key
    // ========================================
    
    struct Location {
        @key long building;
        @key short floor;
        long room;
    };

    @topic
    @appendable
    struct NestedKeyTopic {
        @key Location location;
        
        string<128> description;
        double temperature;
        Timestamp last_updated;
    };
    
    // ========================================
    // TEST 4: Sequences (Various Types)
    // ========================================
    
    typedef string<16> BoundedString16;
    typedef sequence<long> LongSeq;
    typedef sequence<double, 5> BoundedDoubleSeq;
    
    @topic
    @appendable
    struct SequenceTopic {
        @key long id;
        
        // Primitive sequences
        sequence<long> unbounded_long_seq;
        sequence<long, 10> bounded_long_seq;
        sequence<double> unbounded_double_seq;
        sequence<BoundedString16> string_seq;
        
        // Enum sequence
        sequence<Color> color_seq;
    };
    
    // ========================================
    // TEST 5: Nested Sequences
    // ========================================
    
    @topic
    struct NestedSequences {
        @key long id;
        
        // Sequence of sequences
        sequence<LongSeq> seq_of_seq;
        sequence<BoundedDoubleSeq> bounded_seq_of_seq;
        
        // Sequence of structs
        sequence<Point2D> point_seq;
    };
    
    // ========================================
    // TEST 6: Arrays (Single & Multi-dimensional)
    // ========================================
    
    @topic
    struct ArrayTopic {
        @key long id;
        
        // Single-dimensional arrays
        long long_array[10];
        double double_array[5];
        Color color_array[3];
        
        // Multi-dimensional arrays
        Point2D matrix_2d[3][3];
        long cube[2][2][2];
    };
    
    // ========================================
    // TEST 7: Strings (Bounded & Unbounded)
    // ========================================
    
    @topic
    struct StringTopic {
        @key long id;
        
        // Bounded strings
        string<32> short_str;
        string<128> medium_str;
        string<512> long_str;
        
        // Sequence of strings - using typedef to avoid parser issues
        // sequence<string<64>> str_seq; 
        // Note: Some IDL parsers struggle with anonymous sequences of anonymous strings
        sequence<string> str_seq; 
        
        // Array of strings
        string<32> str_array[5];
    };
    
    // ========================================
    // TEST 8: Optional Fields (XTypes)
    // ========================================
    
    struct NestedStruct {
        long value;
        string<64> label;
    };
    
    @topic
    struct OptionalFields {
        @key long id;
        
        @optional long optional_int;
        @optional double optional_double;
        @optional string<128> optional_str;
        @optional NestedStruct optional_struct;
    };
    
    // ========================================
    // TEST 9: Complex Nested Structure
    // ========================================
    
    struct Address {
        string<128> street;
        string<64> city;
        long zip_code;
    };
    
    struct ContactInfo {
        string<64> email;
        string<32> phone;
        Address address;
    };
    
    @topic
    struct Person {
        @key long person_id;
        
        string<128> name;
        long age;
        ContactInfo contact;
        sequence<Address> previous_addresses;
    };
    
    // ========================================
    // TEST 10: Union Topic
    // ========================================
    
    @topic
    struct UnionTopic {
        @key long id;
        
        Status status;
        Shape shape_union;
        Value value_union;
        ColoredValue colored_union;
    };
    
    // ========================================
    // TEST 11: Typedef Chains
    // ========================================
    
    typedef long MyLong;
    typedef MyLong Age;
    typedef Age AgeAlias;
    typedef sequence<Age> AgeSeq;
    
    @topic
    struct TypedefChain {
        @key MyLong id;
        Age person_age;
        AgeAlias alias_age;
        AgeSeq age_history;
    };
    
    // ========================================
    // TEST 12: Mixed Complex Content
    // ========================================
    
    @topic
    struct MixedComplexTopic {
        @key long id;
        
        // Primitives
        boolean active;
        double score;
        
        // Enums
        Priority priority;
        Status status;
        
        // Nested structs
        Point3D position;
        Timestamp created_at;
        
        // Sequences
        sequence<long> measurements;
        sequence<Point2D> trajectory;
        
        // Arrays
        Color color_palette[4];
        double matrix[2][3];
        
        // Unions
        Shape shape;
        
        // Strings
        string<256> description;
        // sequence<string<32>> tags; // Parser issue
        sequence<string> tags;
    };
    
    // ========================================
    // TEST 13: Large Payload (Fragmentation Test)
    // ========================================
    
    @topic
    struct LargePayload {
        @key long id;
        
        // Large arrays to test fragmentation
        octet binary_data[8192];        // 8 KB
        long large_array[2048];         // ~8 KB
        string<1024> large_string;
        sequence<double> large_seq;     // Variable size
    };
    
    // ========================================
    // TEST 14: Multi-Instance Test
    // ========================================
    
    @topic
    struct SensorData {
        @key long sensor_id;
        @key long device_id;
        
        Timestamp timestamp;
        double temperature;
        double humidity;
        double pressure;
        Status operational_status;
    };
    
    // ========================================
    // TEST 15: Deeply Nested Structure
    // ========================================
    
    struct Level3 {
        long value3;
        string<32> label3;
    };
    
    struct Level2 {
        long value2;
        Level3 nested3;
        sequence<Level3> seq3;
    };
    
    struct Level1 {
        long value1;
        Level2 nested2;
        sequence<Level2> seq2;
    };
    
    @topic
    struct DeepNesting {
        @key long id;
        Level1 root;
    };
};
