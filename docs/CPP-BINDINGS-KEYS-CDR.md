# C++ Bindings: Keys and CDR Serialization

## Overview
This document details how the C++ bindings (`cyclonedds-cxx`) handle key serialization and CDR processing, based on an analysis of `datatopic.hpp` and related files. It highlights the differences between the C++ approach and the current C# implementation, providing insights into resolving key-related serialization issues.

## C++ Bindings Approach

### 1. Custom Serdata (`ddscxx_serdata`)
*   **Mechanism**: The C++ bindings do **not** use the generic `dds_create_serdata_from_cdr` function provided by the native library.
*   **Implementation**: They define a custom `ddscxx_serdata` class that inherits from `ddsi_serdata`.
*   **Ops**: They implement a custom `ddsi_serdata_ops` vtable (`ddscxx_serdata_ops`) which provides callbacks for:
    *   `get_size`
    *   `eqkey` (Equality check for keys)
    *   `from_ser` (Deserialization from serialized blob)
    *   `to_ser` (Serialization to blob)
    *   `to_key` (Key extraction/hashing)
    *   `from_sample` / `to_sample`
*   **Registration**: This custom serdata implementation is registered with the native core using `dds_create_topic_sertype`, passing the custom ops and a pointer to the `TopicTraits`.

### 2. Key Serialization (`to_key`)
*   **Purpose**: To generate a canonical key value or hash for instance management.
*   **Process**:
    1.  **Check Keyless**: If the topic is keyless, it returns a zeroed hash.
    2.  **Canonical Stream**: It creates a `basic_cdr_stream` with **Big Endian** encoding. This is crucial because DDS keys are typically hashed in a canonical format (often Big Endian CDR) to ensure consistency across different platforms.
    3.  **Serialize Keys**: It calls `write(str, tokey, key_mode::sorted)` to serialize *only* the key fields into this stream.
    4.  **Hashing**:
        *   If the serialized key is small (<= 16 bytes), it copies it directly to the `ddsi_keyhash_t`.
        *   If larger, it computes an **MD5 hash** of the serialized key buffer.
*   **Independence**: This process is independent of the main sample serialization. It ensures that keys are always handled consistently, regardless of the sample's encoding (XCDR1/XCDR2).

### 3. Sample Serialization (`serdata_from_sample`)
*   **Header**: The C++ bindings explicitly handle the 4-byte RTPS/CDR encapsulation header.
    *   `write_header` writes the header based on the type's extensibility (`@final`, `@appendable`, `@mutable`) and the native endianness.
    *   **Final**: `DDSI_RTPS_CDR_LE` (0x0001) / `BE` (0x0000).
    *   **Appendable**: `DDSI_RTPS_D_CDR2_LE` (0x0009) for XCDR2.
    *   **Mutable**: `DDSI_RTPS_PL_CDR2_LE` (0x000b) for XCDR2.
*   **Payload**: The sample data is written after the header.
*   **Key Population**: After serializing the data, it calls `to_key` to populate the keyhash in the `serdata` object.

### 4. Deserialization
*   **Header Parsing**: `read_header` reads the first 4 bytes to determine the encoding version (XCDR1 vs XCDR2) and endianness.
*   **Offset**: It then passes the buffer **offset by 4 bytes** (`DDSI_RTPS_HEADER_SIZE`) to the deserialization logic (`deserialize_sample_from_buffer_impl`).

## Comparison with C# Bindings

| Feature | C++ Bindings | C# Bindings (Current) |
| :--- | :--- | :--- |
| **Serdata** | Custom `ddscxx_serdata` via `dds_create_topic_sertype` | Default native serdata via `dds_create_serdata_from_cdr` |
| **Key Extraction** | Explicit `to_key` function (C# side logic) | Relies on native library parsing `_ops` from descriptor |
| **Header Handling** | Explicit read/write in C++ | `DdsWriter` prepends header; `DdsReader` skips it (manually) |
| **DHEADER (Length)** | Handled by XCDR2 streams if needed | **Potential Missing Link**: `Serializer` might not be writing DHEADER for `@appendable` |

## Conclusion & Recommendations

1.  **The "Black Box" Issue**: By using `dds_create_serdata_from_cdr`, we are relying on the native library to correctly parse our serialized data using the generated `_ops`.
2.  **`DDS_OP_DLC` and DHEADER**: The `DDS_OP_DLC` instruction in `_ops` (generated for `@appendable` types) likely tells the native parser to expect a **DHEADER** (4-byte length) at the start of the payload (after the Encapsulation Header).
3.  **Mismatch Hypothesis**: If our C# `Serializer` does *not* write this DHEADER for `@appendable` types, but the `_ops` contain `DDS_OP_DLC`, the native parser will misinterpret the data (reading the first 4 bytes of data as the length), leading to `dds_create_serdata_from_cdr` failure or key corruption.
4.  **Immediate Fix**: Verify if `SerializerEmitter.cs` writes the DHEADER (int32 length) for `@appendable` types. If not, implement it. This should align the serialized data with the `_ops` generated by `idlc`.
5.  **Long-Term**: Moving to a custom serdata implementation (like C++) would give us full control and eliminate reliance on opaque native parsing logic, but it requires significant effort (P/Invoke callbacks, memory management).
