# JSON-Based Descriptor Parser Migration Guide

**Date:** January 24, 2026  
**Project:** FastCycloneDdsCsharpBindings  
**Status:** Implementation Plan

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Current Implementation Analysis](#current-implementation-analysis)
3. [Problem Statement](#problem-statement)
4. [Proposed Solution](#proposed-solution)
5. [Implementation Plan](#implementation-plan)
6. [File-by-File Changes](#file-by-file-changes)
7. [Test Migration Strategy](#test-migration-strategy)
8. [Benefits and Impact](#benefits-and-impact)
9. [Migration Checklist](#migration-checklist)

---

## Executive Summary

This document outlines the migration from **C-header parsing** (using `CppAst` with fragile regex heuristics) to **JSON-based descriptor parsing** (using `idlc -l json` with structured metadata). This change eliminates the most unreliable component in the toolchain and provides accurate, pre-calculated type descriptors directly from Cyclone DDS.

### Key Changes

- **Remove:** `DescriptorParser.cs` (691 lines of brittle C parsing)
- **Remove:** `DescriptorMetadata.cs` (simple data structure)
- **Remove:** NuGet packages: `CppAst`, `libclang.runtime.win-x64`, `libClangSharp.runtime.win-x64`
- **Add:** `IdlJson/JsonModels.cs` (~150 lines of JSON schema classes)
- **Add:** `IdlJsonParser.cs` (~100 lines of clean JSON parsing)
- **Update:** `IdlcRunner.cs` (change `-l c` to `-l json`)
- **Update:** `CodeGenerator.cs` (`GenerateDescriptors` method)
- **Rewrite:** `DescriptorParserTests.cs` (switch from C parsing tests to JSON parsing tests)

---

## Current Implementation Analysis

### Architecture Overview

The current system follows this workflow:

```
IDL File → idlc -l c → .c/.h files → CppAst Parser → DescriptorMetadata → C# Code
```

### Components

#### 1. `DescriptorParser.cs` (691 lines)

**Purpose:** Parses C header files generated by `idlc` to extract:
- Serialization opcodes (`uint32_t TypeName_ops[]`)
- Key descriptors (`dds_key_descriptor_t TypeName_keys[]`)
- Member offsets (calculated from `offsetof()` macros)

**Implementation:**
- Uses `CppAst` library (C/C++ parser built on libclang)
- Requires extensive workarounds for header parsing:
  - Mock typedefs for `uint32_t`, `uint8_t`, etc.
  - Regex-based struct/enum extraction to bypass CppAst limitations
  - Custom macro resolution (`DDS_OP_ADR`, `DDS_OP_TYPE_4BY`, etc.)
  - Manual offset calculation with alignment rules
  - Recursive include resolution
  - Special handling for `offsetof()` macros

**Key Methods:**
```csharp
public DescriptorMetadata ParseDescriptor(string cFilePath, string? typeName = null)
private uint[] ParseArrayInitializer(CppExpression? initExpression, bool isOps)
private uint[] ResolveOffsets(List<uint?> rawValues)
private KeyDescriptorInfo[] ParseKeysUsingRegex(string cContent, ...)
private (uint size, uint align) GetTypeSizeAndAlign(uint typeCode)
```

**Fragility Points:**
1. CppAst may fail on complex C code
2. Offset calculation assumes specific padding/alignment rules
3. Regex parsing of key descriptors is error-prone
4. Dependent on C code generation format staying constant
5. Requires native libclang libraries (platform-specific)

#### 2. `DescriptorMetadata.cs` (20 lines)

**Purpose:** Simple data structure to hold parsed descriptor information

```csharp
public class DescriptorMetadata
{
    public string TypeName { get; set; }
    public string OpsArrayName { get; set; }
    public uint[] OpsValues { get; set; }
    public string KeysArrayName { get; set; }
    public KeyDescriptorInfo[] KeyDescriptors { get; set; }
}

public class KeyDescriptorInfo
{
    public string Name { get; set; }
    public uint Offset { get; set; }
    public uint Index { get; set; }
}
```

#### 3. `IdlcRunner.cs` (Current)

**Current Command:**
```csharp
Arguments = $"-l c -o \"{outputDir}\" \"{idlFilePath}\""
```

Generates: `TypeName.c` and `TypeName.h`

#### 4. `CodeGenerator.GenerateDescriptors()` (Lines 199-300)

**Current Flow:**
1. Run `idlc -l c` for each IDL file
2. Create `DescriptorParser` instance
3. Parse generated `.c` file
4. Extract metadata
5. Generate `TypeName.Descriptor.cs` with:
   - Static `uint[] _ops` array
   - Static `DdsKeyDescriptor[] _keys` array
   - Static methods to retrieve them

#### 5. `DescriptorParserTests.cs`

**Current Tests:**
- `ParseDescriptor_ExtractsOpsArray()` - Verifies ops array parsing
- `ParseDescriptor_HandlesMacros()` - Tests macro resolution
- `ParseDescriptor_CalculatesOffsetOf()` - Validates offset calculation
- `ParseDescriptor_ExtractsKeys()` - Tests key array extraction
- `ParseDescriptor_HandlesAlignment()` - Verifies struct alignment

All tests create temporary C files and parse them.

---

## Problem Statement

### Critical Issues

1. **Reliability:** `CppAst` parsing fails on complex headers, requires extensive mocking
2. **Accuracy:** Offset calculation may diverge from actual Cyclone DDS layout
3. **Maintenance:** 691 lines of complex parsing logic with edge cases
4. **Platform Dependencies:** Requires platform-specific `libclang` binaries
5. **Brittleness:** Changes to `idlc` C output format can break parsing
6. **Debug Difficulty:** When offsets are wrong, debugging is extremely difficult

### Example Failure Scenario

```c
// Generated by idlc -l c
typedef struct MyTopic {
    uint32_t key_id;
    char padding[3];  // Compiler-inserted padding
    float value;
} MyTopic;
```

If the C# offset calculator doesn't match the C compiler's padding rules exactly, the descriptor will be wrong, causing:
- Incorrect serialization
- Data corruption
- Intermittent failures in roundtrip tests

---

## Proposed Solution

### New Architecture

```
IDL File → idlc -l json → .json file → JsonParser → TypeDescriptor → C# Code
```

### Why This Works

The `idlc -l json` plugin (IDLJSON) provides:

1. ✅ **Pre-calculated offsets** - Computed by the same code that generates C structures
2. ✅ **Exact opcodes** - Generated by Cyclone DDS's authoritative opcode generator
3. ✅ **Structured metadata** - Clean JSON schema, no parsing ambiguity
4. ✅ **Platform independence** - No native dependencies, pure C# `System.Text.Json`
5. ✅ **Future-proof** - Changes to opcode generation automatically reflected in JSON

### JSON Schema (Simplified)

From `IDLJSON-README.md`:

```json
{
  "File": [ { "Name": "MyTypes.idl" } ],
  "Types": [
    {
      "Name": "Vehicle",
      "Kind": "struct",
      "Extensibility": "final",
      "TopicDescriptor": {
        "Size": 88,
        "Align": 8,
        "FlagSet": 0,
        "TypeName": "Vehicle",
        "Keys": [
          { "Name": "vehicle_id", "Offset": 0, "Order": 0 }
        ],
        "Ops": [ 251658244, 1, 196609, 0, 196609, 4, ... ]
      },
      "Members": [
        { "Name": "vehicle_id", "Type": "unsigned long", "IsKey": true },
        { "Name": "model", "Type": "string", "Bound": 64 },
        { "Name": "speed", "Type": "double" }
      ]
    }
  ]
}
```

**Critical Fields:**
- `TopicDescriptor.Ops` - Pre-built opcodes array (no calculation needed!)
- `TopicDescriptor.Keys[].Offset` - Pre-calculated byte offsets (exact!)
- `TopicDescriptor.Size/Align` - Struct layout information
- `Members[].IsKey` - Key field identification

---

## Implementation Plan

### Phase 1: Create JSON Models ✅

**File:** `tools/CycloneDDS.CodeGen/IdlJson/JsonModels.cs` (New)

Define C# classes matching the JSON schema:

```csharp
namespace CycloneDDS.CodeGen.IdlJson
{
    public class IdlJsonRoot
    {
        [JsonPropertyName("File")]
        public List<JsonFileMeta> File { get; set; } = new();

        [JsonPropertyName("Types")]
        public List<JsonTypeDefinition> Types { get; set; } = new();
    }

    public class JsonTypeDefinition
    {
        public string Name { get; set; } = string.Empty;
        public string Kind { get; set; } = string.Empty; // "struct", "union", "enum"
        public string Extensibility { get; set; } = string.Empty;
        public List<JsonMember> Members { get; set; } = new();
        public JsonTopicDescriptor? TopicDescriptor { get; set; }
    }

    public class JsonTopicDescriptor
    {
        public uint Size { get; set; }
        public uint Align { get; set; }
        public uint FlagSet { get; set; }
        public string TypeName { get; set; } = string.Empty;
        public List<JsonKeyDescriptor> Keys { get; set; } = new();
        public long[] Ops { get; set; } = Array.Empty<long>();
    }

    public class JsonKeyDescriptor
    {
        public string Name { get; set; } = string.Empty;
        public uint Offset { get; set; }
        public uint Order { get; set; }
    }

    // Additional classes: JsonMember, JsonFileMeta
}
```

### Phase 2: Create JSON Parser ✅

**File:** `tools/CycloneDDS.CodeGen/IdlJsonParser.cs` (New)

Simple, clean parser using `System.Text.Json`:

```csharp
public class IdlJsonParser
{
    public List<JsonTypeDefinition> Parse(string jsonFilePath)
    {
        if (!File.Exists(jsonFilePath))
            throw new FileNotFoundException($"IDL JSON not found: {jsonFilePath}");

        string jsonContent = File.ReadAllText(jsonFilePath);
        
        var options = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            AllowTrailingCommas = true
        };

        try 
        {
            var root = JsonSerializer.Deserialize<IdlJsonRoot>(jsonContent, options);
            return root?.Types ?? new List<JsonTypeDefinition>();
        }
        catch (JsonException ex)
        {
            throw new InvalidOperationException(
                $"Failed to parse IDL JSON: {ex.Message}", ex);
        }
    }
}
```

### Phase 3: Update IdlcRunner ✅

**File:** `tools/CycloneDDS.CodeGen/IdlcRunner.cs`

**Change:**
```csharp
// OLD:
Arguments = $"-l c -o \"{outputDir}\" \"{idlFilePath}\""
GeneratedFiles = Directory.GetFiles(outputDir, "*.c")

// NEW:
Arguments = $"-l json -o \"{outputDir}\" \"{idlFilePath}\""
GeneratedFiles = Directory.GetFiles(outputDir, "*.json")
```

### Phase 4: Update CodeGenerator ✅

**File:** `tools/CycloneDDS.CodeGen/CodeGenerator.cs`

**Replace `GenerateDescriptors` method:**

```csharp
private void GenerateDescriptors(GlobalTypeRegistry registry, string outputDir)
{
    var fileGroups = registry.LocalTypes
        .Where(t => t.TypeInfo != null && (t.TypeInfo.IsTopic || t.TypeInfo.IsStruct))
        .GroupBy(t => t.TargetIdlFile);

    var idlcRunner = new IdlcRunner();
    var jsonParser = new IdlJsonParser();
    var processedIdlFiles = new HashSet<string>();

    foreach (var group in fileGroups)
    {
        string idlFileName = group.Key;
        string idlPath = Path.Combine(outputDir, $"{idlFileName}.idl");
        
        if (!processedIdlFiles.Contains(idlFileName))
        {
            // 1. Run IDLC (JSON mode)
            var result = idlcRunner.RunIdlc(idlPath, outputDir);
            if (result.ExitCode != 0)
            {
                Console.Error.WriteLine($"idlc failed for {idlFileName}: {result.StandardError}");
                continue; 
            }
            processedIdlFiles.Add(idlFileName);
            
            // 2. Parse JSON
            string jsonFile = Path.Combine(outputDir, $"{idlFileName}.json");
            if (File.Exists(jsonFile))
            {
                var jsonTypes = jsonParser.Parse(jsonFile);
                
                // 3. Match JSON types to C# types
                foreach (var csharpType in group)
                {
                    // C#: MyNamespace.MyTopic
                    // IDL/JSON: MyNamespace::MyTopic
                    string idlName = csharpType.CSharpFullName.Replace(".", "::");
                    
                    var jsonDef = jsonTypes.FirstOrDefault(t => t.Name == idlName);
                    
                    if (jsonDef?.TopicDescriptor != null)
                    {
                        // 4. Generate Descriptor Code
                        string descCode = GenerateDescriptorCode(
                            csharpType.TypeInfo, 
                            jsonDef.TopicDescriptor);
                        
                        string outputPath = Path.Combine(
                            outputDir, 
                            $"{csharpType.TypeInfo.Name}.Descriptor.cs");
                        
                        File.WriteAllText(outputPath, descCode);
                        Console.WriteLine($"Generated Descriptor for {csharpType.TypeInfo.Name}");
                    }
                }
            }
        }
    }
}

private string GenerateDescriptorCode(TypeInfo type, JsonTopicDescriptor desc)
{
    var sb = new StringBuilder();
    sb.AppendLine("using System;");
    sb.AppendLine("using CycloneDDS.Runtime;");
    sb.AppendLine();
    
    if (!string.IsNullOrEmpty(type.Namespace))
    {
        sb.AppendLine($"namespace {type.Namespace}");
        sb.AppendLine("{");
    }
    
    sb.AppendLine($"    public partial struct {type.Name}");
    sb.AppendLine("    {");
    
    // OPS - Direct from JSON!
    sb.Append("        private static readonly uint[] _ops = new uint[] { ");
    var opsString = string.Join(", ", desc.Ops.Select(op => (uint)op));
    sb.Append(opsString);
    sb.AppendLine(" };");
    sb.AppendLine("        public static uint[] GetDescriptorOps() => _ops;");

    // KEYS - Pre-calculated offsets!
    if (desc.Keys != null && desc.Keys.Count > 0)
    {
        sb.AppendLine();
        sb.AppendLine("        private static readonly DdsKeyDescriptor[] _keys = new DdsKeyDescriptor[]");
        sb.AppendLine("        {");
        foreach(var key in desc.Keys)
        {
            sb.AppendLine($"            new DdsKeyDescriptor {{ Name = \"{key.Name}\", Offset = {key.Offset}, Index = {key.Order} }},");
        }
        sb.AppendLine("        };");
        sb.AppendLine("        public static DdsKeyDescriptor[] GetKeyDescriptors() => _keys;");
    }
    else
    {
        sb.AppendLine("        public static DdsKeyDescriptor[] GetKeyDescriptors() => null;");
    }

    // FLAGSET
    sb.AppendLine();
    sb.AppendLine($"        public static uint GetDescriptorFlagset() => {desc.FlagSet};");
    
    sb.AppendLine("    }");
    
    if (!string.IsNullOrEmpty(type.Namespace))
    {
        sb.AppendLine("}");
    }
    
    return sb.ToString(); 
}
```

### Phase 5: Update Tests ✅

**File:** `tests/CycloneDDS.CodeGen.Tests/DescriptorParserTests.cs`

**Rename to:** `tests/CycloneDDS.CodeGen.Tests/IdlJsonParserTests.cs`

**Rewrite tests:**

```csharp
public class IdlJsonParserTests : IDisposable
{
    private readonly string _tempDir;

    [Fact]
    public void Parse_ExtractsOpsArray()
    {
        string json = @"{
            ""Types"": [{
                ""Name"": ""TestData"",
                ""Kind"": ""struct"",
                ""TopicDescriptor"": {
                    ""Ops"": [67108868, 0, 1],
                    ""Keys"": []
                }
            }]
        }";
        
        var file = CreateTempFile("test.json", json);
        var parser = new IdlJsonParser();
        var types = parser.Parse(file);

        Assert.Single(types);
        Assert.Equal("TestData", types[0].Name);
        Assert.Equal(3, types[0].TopicDescriptor.Ops.Length);
        Assert.Equal(67108868, types[0].TopicDescriptor.Ops[0]);
    }

    [Fact]
    public void Parse_ExtractsKeyDescriptors()
    {
        string json = @"{
            ""Types"": [{
                ""Name"": ""Vehicle"",
                ""TopicDescriptor"": {
                    ""Ops"": [251658244, 1],
                    ""Keys"": [
                        { ""Name"": ""vehicle_id"", ""Offset"": 0, ""Order"": 0 }
                    ]
                }
            }]
        }";
        
        var file = CreateTempFile("vehicle.json", json);
        var parser = new IdlJsonParser();
        var types = parser.Parse(file);

        var keys = types[0].TopicDescriptor.Keys;
        Assert.Single(keys);
        Assert.Equal("vehicle_id", keys[0].Name);
        Assert.Equal(0u, keys[0].Offset);
        Assert.Equal(0u, keys[0].Order);
    }

    [Fact]
    public void Parse_HandlesMultipleTypes()
    {
        string json = @"{
            ""Types"": [
                { ""Name"": ""Type1"", ""Kind"": ""struct"" },
                { ""Name"": ""Type2"", ""Kind"": ""struct"" }
            ]
        }";
        
        var file = CreateTempFile("multi.json", json);
        var parser = new IdlJsonParser();
        var types = parser.Parse(file);

        Assert.Equal(2, types.Count);
        Assert.Equal("Type1", types[0].Name);
        Assert.Equal("Type2", types[1].Name);
    }
}
```

### Phase 6: Clean Up Dependencies ✅

**File:** `tools/CycloneDDS.CodeGen/CycloneDDS.CodeGen.csproj`

**Remove:**
```xml
<PackageReference Include="CppAst" Version="0.14.0" />
<PackageReference Include="libclang.runtime.win-x64" Version="21.1.8" />
<PackageReference Include="libClangSharp.runtime.win-x64" Version="21.1.8.2" />
```

**Delete Files:**
- `tools/CycloneDDS.CodeGen/DescriptorParser.cs`
- `tools/CycloneDDS.CodeGen/DescriptorMetadata.cs`

---

## File-by-File Changes

### New Files

| File | Lines | Purpose |
|------|-------|---------|
| `tools/CycloneDDS.CodeGen/IdlJson/JsonModels.cs` | ~150 | JSON schema classes |
| `tools/CycloneDDS.CodeGen/IdlJsonParser.cs` | ~80 | JSON parsing logic |

### Modified Files

| File | Changes | Impact |
|------|---------|--------|
| `tools/CycloneDDS.CodeGen/IdlcRunner.cs` | Change `-l c` to `-l json` | Low |
| `tools/CycloneDDS.CodeGen/CodeGenerator.cs` | Replace `GenerateDescriptors()` method | Medium |
| `tools/CycloneDDS.CodeGen/CycloneDDS.CodeGen.csproj` | Remove 3 NuGet packages | Low |
| `tests/CycloneDDS.CodeGen.Tests/DescriptorParserTests.cs` | Rewrite as `IdlJsonParserTests.cs` | Medium |

### Deleted Files

| File | Lines | Replaced By |
|------|-------|-------------|
| `tools/CycloneDDS.CodeGen/DescriptorParser.cs` | 691 | `IdlJsonParser.cs` (80 lines) |
| `tools/CycloneDDS.CodeGen/DescriptorMetadata.cs` | 20 | `JsonModels.cs` classes |

---

## Test Migration Strategy

### Current Test Coverage

`DescriptorParserTests.cs` tests:
1. Ops array extraction from C code
2. Macro resolution (`DDS_OP_ADR | DDS_OP_TYPE_4BY`)
3. Offset calculation with alignment
4. Key descriptor parsing
5. Struct alignment rules

### New Test Coverage

`IdlJsonParserTests.cs` will test:
1. ✅ JSON deserialization correctness
2. ✅ Ops array extraction from JSON
3. ✅ Key descriptor extraction with pre-calculated offsets
4. ✅ Multiple type handling
5. ✅ Error handling (malformed JSON)
6. ✅ Missing TopicDescriptor handling

### Integration Tests

**Create:** `tests/CycloneDDS.CodeGen.Tests/IdlJsonIntegrationTests.cs`

Test full pipeline:
```csharp
[Fact]
public void EndToEnd_GeneratesDescriptorFromJson()
{
    // 1. Write IDL file
    string idl = @"
        @topic
        struct TestTopic {
            @key long id;
            double value;
        };
    ";
    
    // 2. Run idlc -l json
    var runner = new IdlcRunner();
    var result = runner.RunIdlc(idlPath, outputDir);
    
    // 3. Parse JSON
    var parser = new IdlJsonParser();
    var types = parser.Parse(jsonPath);
    
    // 4. Verify descriptor
    var desc = types[0].TopicDescriptor;
    Assert.NotNull(desc);
    Assert.NotEmpty(desc.Ops);
    Assert.Single(desc.Keys);
    Assert.Equal("id", desc.Keys[0].Name);
}
```

---

## Benefits and Impact

### Benefits

| Category | Benefit | Impact |
|----------|---------|--------|
| **Reliability** | No more fragile C parsing | ⭐⭐⭐⭐⭐ |
| **Accuracy** | Offsets guaranteed correct | ⭐⭐⭐⭐⭐ |
| **Maintainability** | 691 → 80 lines of parsing | ⭐⭐⭐⭐⭐ |
| **Platform Independence** | No native dependencies | ⭐⭐⭐⭐ |
| **Performance** | JSON parsing faster than CppAst | ⭐⭐⭐ |
| **Debuggability** | Human-readable JSON | ⭐⭐⭐⭐ |

### Code Size Impact

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| Parsing logic | 691 lines | 80 lines | **-88%** |
| NuGet packages | 3 (native) | 0 | **-100%** |
| Test complexity | High (C mocking) | Low (JSON strings) | **Simplified** |

### Risk Assessment

| Risk | Likelihood | Mitigation |
|------|------------|------------|
| IDLJSON bugs | Low | JSON plugin is well-tested, part of Cyclone DDS |
| Schema changes | Low | JSON schema is stable, documented |
| Missing features | Low | All required fields present in JSON |
| Migration errors | Medium | Comprehensive test coverage, side-by-side validation |

---

## Migration Checklist

### Pre-Migration

- [ ] Verify `idlc -l json` works on all IDL files in project
- [ ] Review IDLJSON-README.md for schema details
- [ ] Check `cyclone-compiled/bin/cycloneddsidljson.dll` exists
- [ ] Backup current implementation (commit to git)

### Implementation

- [ ] Create `IdlJson/JsonModels.cs` with all schema classes
- [ ] Create `IdlJsonParser.cs` with JSON parsing logic
- [ ] Update `IdlcRunner.cs` to use `-l json`
- [ ] Update `CodeGenerator.GenerateDescriptors()` method
- [ ] Update `CodeGenerator.GenerateDescriptorCode()` method

### Testing

- [ ] Create `IdlJsonParserTests.cs` with unit tests
- [ ] Create `IdlJsonIntegrationTests.cs` for end-to-end tests
- [ ] Run all existing tests to verify no regressions
- [ ] Test with sample IDL files from roundtrip tests
- [ ] Verify generated descriptors match expected format

### Cleanup

- [ ] Delete `DescriptorParser.cs`
- [ ] Delete `DescriptorMetadata.cs`
- [ ] Remove `CppAst` from `CycloneDDS.CodeGen.csproj`
- [ ] Remove `libclang.runtime.win-x64` from `CycloneDDS.CodeGen.csproj`
- [ ] Remove `libClangSharp.runtime.win-x64` from `CycloneDDS.CodeGen.csproj`
- [ ] Clean and rebuild solution

### Validation

- [ ] Run roundtrip tests (C# ↔ Native)
- [ ] Verify descriptor offsets are correct
- [ ] Test keyed topics
- [ ] Test nested structures
- [ ] Test arrays and sequences
- [ ] Test unions
- [ ] Performance comparison (optional)

### Documentation

- [ ] Update README.md with new approach
- [ ] Document JSON schema usage in IDL-GENERATION.md
- [ ] Add troubleshooting guide for JSON parsing
- [ ] Update developer documentation

---

## Appendix A: JSON Schema Reference

### Core Structure

```json
{
  "File": [ { "Name": "filename.idl" } ],
  "Types": [ /* Type definitions */ ]
}
```

### Type Definition Fields

| Field | Type | Description |
|-------|------|-------------|
| `Name` | string | Fully-qualified type name (e.g., `MyModule::MyStruct`) |
| `Kind` | string | `"struct"`, `"union"`, `"enum"`, `"alias"` |
| `Extensibility` | string | `"final"`, `"appendable"`, `"mutable"` |
| `Members` | array | Member definitions |
| `TopicDescriptor` | object | **Critical for DDS topics** |

### TopicDescriptor Fields

| Field | Type | Description |
|-------|------|-------------|
| `Size` | uint | Struct size in bytes |
| `Align` | uint | Struct alignment |
| `FlagSet` | uint | DDS flags |
| `TypeName` | string | Type name |
| `Keys` | array | Key field descriptors |
| `Ops` | array | **Serialization opcodes** |

### Key Descriptor Fields

| Field | Type | Description |
|-------|------|-------------|
| `Name` | string | Field name |
| `Offset` | uint | **Byte offset in struct** |
| `Order` | uint | Key order/index |

---

## Appendix B: Example Generated Code

### Input IDL

```idl
@topic
struct SensorData {
    @key long sensor_id;
    float temperature;
    double pressure;
};
```

### Generated JSON (Excerpt)

```json
{
  "Types": [{
    "Name": "SensorData",
    "TopicDescriptor": {
      "Ops": [251658244, 1, 196609, 0, 196609, 4, 196609, 8, 196609, 16, 0],
      "Keys": [{ "Name": "sensor_id", "Offset": 0, "Order": 0 }],
      "FlagSet": 0
    }
  }]
}
```

### Generated C# (New Approach)

```csharp
public partial struct SensorData
{
    private static readonly uint[] _ops = new uint[] { 
        251658244, 1, 196609, 0, 196609, 4, 196609, 8, 196609, 16, 0 
    };
    
    public static uint[] GetDescriptorOps() => _ops;

    private static readonly DdsKeyDescriptor[] _keys = new DdsKeyDescriptor[]
    {
        new DdsKeyDescriptor { Name = "sensor_id", Offset = 0, Index = 0 }
    };
    
    public static DdsKeyDescriptor[] GetKeyDescriptors() => _keys;
    
    public static uint GetDescriptorFlagset() => 0;
}
```

**Key Improvements:**
- ✅ Ops array copied directly from JSON (no calculation errors)
- ✅ Offset is exact value from Cyclone DDS (no alignment guesswork)
- ✅ Code generation is simple string concatenation
- ✅ No runtime overhead (all static constants)

---

## Conclusion

This migration eliminates the most fragile component of the toolchain while reducing code complexity by **88%**. The new approach provides:

- ✅ **Guaranteed correctness** - Descriptors come from the source of truth
- ✅ **Simplified maintenance** - 80 lines vs 691 lines of parsing
- ✅ **No platform dependencies** - Pure managed C# code
- ✅ **Better debuggability** - Human-readable JSON intermediate format

**Recommended Timeline:**
- Implementation: 1 day
- Testing: 1 day  
- Validation: 1 day
- **Total: 3 days**

This is a **high-value, low-risk** refactoring that should be prioritized.
