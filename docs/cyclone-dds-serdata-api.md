# **Cyclone DDS Serdata API and XCDR2 Sample Handling**

## **Overview: *What is “serdata”?***

In Cyclone DDS, serdata (serialized data) refers to the internal representation of a DDS sample in its serialized form. Instead of dealing with user-defined types directly, Cyclone’s core can manage data as raw bytes (e.g. XCDR encoding) wrapped in a `ddsi_serdata` structure. This allows advanced users to read or write samples as serialized byte streams (e.g. XCDR2) without conversion to/from typed data. Using serdata APIs, you can fetch samples as raw buffers or inject pre-serialized data into the middleware. Why use serdata? It is useful for building generic gateways, logging, or zero-copy pipelines, where you want to handle the binary representation directly. The serdata mechanism is part of Cyclone’s pluggable *type support* layer (represented by `ddsi_sertype` and `ddsi_serdata` objects for each topic type). By working with serdata, you bypass the normal `dds_write`/`dds_take` API (which converts to/from application types), and instead work with the serialized data bytes and metadata.

## **Key Serdata API Functions and Usage**

Cyclone DDS exposes a set of functions (prefixed with `ddsi_serdata_*`) to create, manipulate, and convert these serialized data objects. Below are the most important functions and how to use them (all operate on `struct ddsi_serdata` and require a corresponding `struct ddsi_sertype` for the data type):

* Creating serdata from application data:  
  * `ddsi_serdata_from_sample(const ddsi_sertype *type, ddsi_serdata_kind kind, const void *sample)`: Serialize a user sample (struct) into a serdata object. Use `kind = SDK_DATA` for a regular write (full data), or `SDK_KEY` for a key-only sample (used for disposes/unregisters). For example, on a dispose you might call `ddsi_serdata_from_sample(myType, SDK_KEY, &sample)`, which will serialize only the key fields (non-key fields are ignored when `kind==KEY`).  
  * `ddsi_serdata_from_ser(const ddsi_sertype *type, ddsi_serdata_kind kind, const ddsi_rdata *fragchain, size_t size)` and `ddsi_serdata_from_ser_iov(const ddsi_sertype *type, ddsi_serdata_kind kind, ddsrt_msg_iovlen_t niov, const ddsrt_iovec_t *iov, size_t size)`: Create a serdata from raw serialized bytes. The `_iov` variant is typically used when you have the encapsulation header and payload separated. For example, Cyclone’s C++ binding uses `ddsi_serdata_from_ser_iov` to combine a 4-byte XCDR header and the payload into one serdata object before writing. Use `kind = SDK_DATA` for a normal data sample or `SDK_KEY` if the serialized data represents only a key.  
* Extracting data from serdata:  
  * `ddsi_serdata_to_sample(const ddsi_serdata *d, void *sample, void **bufptr, void *buflim)`: Deserialize a serdata into an application sample (populating your struct). This returns `false` on error. Typically you won’t call this if you intend to work with raw bytes, but it’s available if needed to convert back to typed data.  
  * `ddsi_serdata_to_ser(const ddsi_serdata *d, size_t offset, size_t sz, void *buf)`: Copy a portion of the serialized byte stream out of a serdata into a user buffer. You can use `offset=0` and `sz = ddsi_serdata_size(d)` to get the entire serialized sample. Notably, bytes 0–3 of the stream are the DDSI encapsulation header (which includes the XCDR encoding identifier and options). The total size reported by `ddsi_serdata_size()` includes this 4-byte header. For an XCDR2-LE encoded sample, for example, the header might be `0x00 0x03 0x00 0x00` (encoding 0x0003 \= PL\_CDR\_LE option for XCDR2 little-endian).  
  * `ddsi_serdata_to_ser_ref(const ddsi_serdata *d, size_t offset, size_t sz, ddsrt_iovec_t *iov)`: Similar to `to_ser`, but instead of copying data out, it gives you a direct memory reference (I/O vector) to the internal serialized data. This is more efficient (zero-copy) and is used when Cyclone loans out the buffer. You must call `ddsi_serdata_to_ser_unref()` later to release the reference. Multiple concurrent `to_ser_ref` calls are allowed. In practice, you might call `ddsi_serdata_to_ser_ref(d, 0, ddsi_serdata_size(d), &iov)` to get a pointer/length for the entire serialized sample.  
  * `ddsi_serdata_size(const ddsi_serdata *d)`: Returns the total serialized size (in bytes) of the sample, including the 4-byte header. If alignment padding is used internally, `size(d)` gives the meaningful bytes (Cyclone aligns to 4-byte boundaries for the header).  
  * Key hash and comparisons: There are utility functions like `ddsi_serdata_get_keyhash(const ddsi_serdata *d, ddsi_keyhash *buf, bool force_md5)` to retrieve a 128-bit key hash from a serdata (especially for key-only samples), and `ddsi_serdata_eqkey(a,b)` to compare two serdata’s key values. These are mainly used internally for instance matching, but you can use them if needed to identify instances.  
* Reference management:  
  * `ddsi_serdata_ref(const ddsi_serdata *d)` and `ddsi_serdata_unref(struct ddsi_serdata *d)`: Bump or decrement the reference count on a serdata. The serdata objects are reference-counted. When you obtain serdata from a read/take call, Cyclone gives it to you with refcount=1 (ownership transferred). You must call `ddsi_serdata_unref()` on each serdata when you’re done to avoid memory leaks. If you create a serdata for writing, you should also unref it after writing (Cyclone will internally take a ref if needed while delivering to readers). Generally, every serdata obtained via API should eventually be unref’d once.  
* Special cases:  
  * `ddsi_serdata_from_keyhash(const ddsi_sertype *type, const ddsi_keyhash *keyhash)`: Construct a serdata representing an instance key (used when you want to directly refer to an instance by key without data). This produces a serdata of kind KEY containing only the key fields.  
  * `ddsi_serdata_from_loaned_sample(...)` and `ddsi_serdata_from_psmx(...)`: These are advanced functions for zero-copy support (loaned samples and shared-memory). For instance, `from_loaned_sample` can wrap a loaned user buffer into a serdata (avoiding an extra serialization copy). Similarly, `from_psmx` is used internally when receiving data from the Iceoryx shared memory transport. In most use-cases, you won’t call these directly unless you are working with Cyclone’s loan API or custom transports.

## **Writing Samples in XCDR2 Format (Using Serdata)**

To publish a serialized sample directly (in XCDR2 format), Cyclone DDS provides the `dds_writecdr` API. This function takes a DataWriter handle and a `ddsi_serdata*` instead of a typed sample. In contrast to `dds_write`, it assumes you’ve already prepared the data in the proper serialized form. According to the Cyclone API docs, `dds_writecdr` will write the provided serialized value *as-is*, using whatever timestamp and status flags are set in the serdata. There’s also `dds_forwardcdr`, which does the same but respects the `serdata->timestamp` if you’ve set one (allowing you to specify an explicit source timestamp). How to use it: First, ensure you have a `ddsi_serdata` for the data you want to write. Typically, you will:

1. Obtain the `ddsi_sertype` for your topic’s type. This is needed to create serdata. When you create a topic in Cyclone (via `dds_create_topic` or the C++ `Topic` class), the middleware generates or registers a `ddsi_sertype` internally. In the Cyclone C API, you usually supply a `dds_topic_descriptor_t` (from IDL code generation or dynamic type) to create the topic. The C++ API caches the sertype for you (e.g. `TopicDescriptionDelegate::ser_type_`). In code, you might get it via an internal call or C++ helper (CycloneDDS-CXX uses `topicDesc->get_ser_type()` under the hood). Assuming you have access to the sertype pointer (we discuss initialization further below), proceed to create the serdata.  
2. Serialize your data into a serdata: You have two options:  
   * If you have a *raw byte buffer* (already in XCDR2 format, including or excluding the header): use `ddsi_serdata_from_ser` or `_from_ser_iov`. For example, Cyclone’s C++ binding provides a `CDRBlob` object that contains a 4-byte encapsulation header and a payload byte array. In their `AnyDataWriterDelegate::write_cdr` implementation, they do:  
   * *`// blob_holders[0] = 4-byte header, blob_holders[1] = payload bytes`* `ser_data = ddsi_serdata_from_ser_iov(topic_sertype, (ddsi_serdata_kind)data->kind(), 2, blob_holders, payload_size + 4); ser_data->statusinfo = statusinfo; // e.g. set dispose/unregister flags if needed`  
      This constructs a contiguous serdata containing the XCDR2 header and payload. Here, `data->kind()` was an enum for Data vs Key (mapped to `SDK_DATA` or `SDK_KEY`), and `statusinfo` can carry flags like *dispose* or *unregister* (Cyclone defines `DDSI_STATUSINFO_DISPOSE` etc., which the C++ code passes for dispose/unregister calls). If you’re doing a normal write, `statusinfo` can be 0\.  
   * If you have a *C struct sample*: use `ddsi_serdata_from_sample`. Cyclone will then invoke the proper serialization internally. Ensure you specify `kind = SDK_DATA` for a write. This is easier if you already have an IDL-generated type support; otherwise, you need a topic descriptor to know how to serialize the struct.  
3. Call `dds_writecdr` or `dds_forwardcdr`: Once you have the `ddsi_serdata*`, call `dds_writecdr(writer_handle, serdata)`. If you want to use a specific timestamp, set `serdata->timestamp` (a `dds_time_t` in nanoseconds) and call `dds_forwardcdr(writer, serdata)` to use it. If you don’t set a timestamp and use `dds_writecdr`, Cyclone will timestamp it with the current time when sending. In either case, the serdata’s contents (including header) are sent directly. For example, the CycloneDDS-CXX code does:  
4. `if (timestamp != Time::invalid()) { ser_data->timestamp.v = custom_time; ret = dds_forwardcdr(writer, ser_data); } else { ret = dds_writecdr(writer, ser_data); }`  
    .  
5. Release the serdata: After `dds_writecdr` returns, you should free your reference to the serdata (unless you plan to reuse it). Typically you’d call `ddsi_serdata_unref(ser_data)` at this point. Cyclone will internally take care of delivering the data to matching readers; your copy can be released. (If you constructed the serdata from a loaned buffer and you want to reuse that buffer, ensure the write is done or use loan APIs appropriately – beyond scope here).

Note: The 4-byte *encapsulation header* must be present and correct in the serdata’s byte stream; Cyclone does not add or fix it for you when using `writecdr`. For XCDR2, this header distinguishes XCDR version and endianness. For example, if your sample is XCDR2 little-endian, the header might be 0x0x00 0x03 0x00 0x00 (where 0x0003 is the *PL\_CDR\_LE* ID for XCDR2 LE). Ensure you use the proper encapsulation ID consistent with your data. (Cyclone’s IDL-generated types handle this automatically; if manually constructing, use the constants in `dds/cdr/dds_cdrstream.h` or see `DDSI_RTPS_CDR2_LE` etc. in Cyclone code.)

## **Reading Samples as Raw CDR (XCDR2)**

On the subscriber side, Cyclone DDS lets you *take* or *read* data as serdata (serialized form) instead of as typed samples. The APIs for this are `dds_readcdr`, `dds_takecdr`, and their instance-specific or peek variants (`dds_readcdr_instance`, `dds_takecdr_instance`, `dds_peekcdr`, etc.). These calls mirror the regular read/take, but fill your buffers with `ddsi_serdata*` references. For example, `dds_takecdr(reader, serdata_array, max_samples, info_array, mask)` will retrieve up to `max_samples` serialized samples from the reader’s cache. If successful, you’ll get an array of `ddsi_serdata*` (one per sample) and corresponding sample info (to check validity, sample state, etc.). Key points when using read/take CDR:

* No conversion or copying to user type: The data remains in Cyclone’s internal serialized form. The `dds_[read|take]cdr` functions *loan* you the serdata objects directly from the reader cache (to avoid copies). This is efficient – especially for large samples or zero-copy shared memory, no extra serialization/deserialization is done.  
* Managing the loan: Because the samples are loaned, you *must return them* when done. In practice, this means calling `ddsi_serdata_unref()` on each returned serdata reference. (Cyclone’s documentation notes that after reading with CDR, the buffer and sample info should be “returned back” once no longer used – releasing the serdata ref is the way to do that.) Each serdata’s type (`serdata->type`) is valid as long as the reader exists, but not guaranteed beyond that, so don’t stash serdata long-term without retaining the participant or reader.  
* Sample info: The `dds_sample_info_t` for each sample will have `valid_data` flag, states, timestamps, etc., just like a normal read. You should check `info[i].valid_data` – if it’s false, the corresponding serdata may represent a disposed instance or no-writers state (and there might not be meaningful data bytes aside from key/hash). Normally, valid\_data will be true for actual data samples.  
* Accessing the serialized bytes: Once you have a `ddsi_serdata*`, you can get at the raw bytes:  
  * For a quick copy, use `ddsi_serdata_to_ser(serdata, 0, ddsi_serdata_size(serdata), user_buffer)`. This will copy the full serialized sample (including header) into your buffer. You need to allocate a buffer of at least `ddsi_serdata_size()` bytes.  
  * For zero-copy access, use `ddsi_serdata_to_ser_ref`. For example, CycloneDDS-C++ uses:  
  * `if (ddsi_serdata_to_ser_ref(sd, 0, ddsi_serdata_size(sd), &blob_content)) { // blob_content now points to the contiguous serialized data ... use blob_content.iov_base and iov_len ... ddsi_serdata_to_ser_unref(sd, &blob_content); }`  
     . This gives a direct pointer into Cyclone’s internal storage. You can then parse it, forward it, or copy it as needed before unref’ing. In their implementation, CycloneDDS-CXX constructs a `CDRBlob` (which has separate `encoding` and `payload` fields) from this buffer: it copies the first 4 bytes into the blob’s `encoding` array and the remaining bytes into the blob’s `payload` vector. You could do something similar – e.g., interpret the first 4 bytes to confirm the encoding, then use the rest as the serialized payload.  
* Cleaning up: After processing the data, call `ddsi_serdata_unref` on each serdata. If you used `to_ser_ref`, also call `ddsi_serdata_to_ser_unref` to release the loan on the internal buffer. It’s important to unref *before* deleting the reader or shutting down the participant, to avoid leaks or use-after-free.

In summary, reading with `dds_takecdr`/`dds_readcdr` gives you an array of serialized samples. You iterate through them, use the serdata API to get the raw bytes or convert to your format, then free the serdata references. This is exactly how the Cyclone DDS C++ *AnyDataReader* works under the hood: it calls `dds_read_with_collector` (a variant that yields serdata via a callback) and then wraps the serdata into CDRBlob objects for the user.

## **Initialization and Setup Requirements**

Using the serdata API directly requires that Cyclone knows the data type (so it can properly serialize/deserialize and manage keys). Before you can use `dds_writecdr` or `dds_takecdr`, you must create a topic (and its associated `ddsi_sertype`) in the usual way. This typically involves either:

* IDL-generated type support (static): If you have an IDL for your type, use the generated `dds_topic_descriptor_t` for that type to create a topic via `dds_create_topic()`. This registers the type with Cyclone. For example, the descriptor contains the type name, size, alignment, key fields, and the serialized opcodes for XCDR encoding. Without this, Cyclone wouldn’t know how to interpret your bytes.  
* Dynamic type support: Cyclone DDS also supports creating types at runtime using the XTypes APIs (e.g., obtaining a `dds_typeinfo_t` or TypeObject from discovery). As of Cyclone DDS 0.8+ you might use `dds_create_topic_descriptor()` or similar if you have a TypeObject. Either way, the goal is to get a `dds_topic_t` associated with a `ddsi_sertype`.

In simpler terms: you cannot use `dds_writecdr` on an arbitrary topic name without defining the type – you’ll get an error. The reader/writer creation will fail if the type is unknown. As one user noted, to use `dds_takecdr` you need a topic, and creating a topic *requires* a topic descriptor (type definition). So ensure the participant knows about the type (either via IDL or dynamic type). Once the topic is created, you can get its `dds_entity_t` for writer/reader and proceed to use the CDR APIs on those entities. Memory allocation and endianness: Cyclone DDS will handle memory allocation for serdata internally when reading (loaning you pointers). The endianness of the data you get from `readcdr` will be the network byte order used by the writer. (In DDS, by default, the sender’s endianness is used for the encapsulation unless you specify otherwise. Cyclone can handle both LE/BE, and it will give you exactly what was received, along with the encapsulation header indicating which it is.) If you create serdata via `from_sample`, Cyclone will produce data in your local machine’s endianness (with the appropriate XCDR header). You can actually choose to produce big-endian or little-endian by specifying the encapsulation in the topic descriptor or by manually adjusting the header bytes if constructing raw data. Summary / Example Workflow:

* Create domain participant.  
* Register type and create topic (e.g., if using IDL: use `dds_create_topic(participant, MyType_desc, "TopicName", qos, NULL)`). This yields a `dds_topic_t` and internally a `ddsi_sertype` for “MyType”.  
* Create a data writer and data reader on that topic (or use existing ones).  
* Writing raw: Prepare your serialized buffer (e.g., using your own XCDR2 serializer or from an external source). Ensure the first 4 bytes are the correct XCDR2 header. Use `dds_writecdr(writer, ddsi_serdata_from_ser_iov(topic_sertype, SDK_DATA, iov, total_size))`. Alternatively, if you only have the payload and know the representation, you may prepend the 4-byte header and call `ddsi_serdata_from_ser` with one buffer. Then unref the serdata after writing.  
* Reading raw: Use `dds_takecdr(reader, serdata_array, MAX_SAMPLES, info_array, STATE_MASK)`. Loop through returned samples: for each `ser = serdata_array[i]` with `info[i].valid_data==true`, get the bytes (e.g., via `ddsi_serdata_to_ser_ref`). Process or store the bytes as needed. Then call `ddsi_serdata_unref(ser)`. Free your `info_array` if dynamically allocated (Cyclone does not allocate it for you; you provide it just like in `dds_take`). If you used a condition or read condition, pass that as the first argument instead of reader.

By following these steps, you bypass the normal (de)serialization overhead and can work with XCDR2 byte streams directly. This is exactly how the CycloneDDS C++ bindings implement their generic data flow: the C++ `AnyDataWriter::write_cdr()` takes a `CDRBlob` (containing an XCDR2 byte array) and uses `ddsi_serdata_from_ser_iov` \+ `dds_writecdr` internally. Similarly, `AnyDataReader::read_cdr()` uses `dds_read_with_collector` to get serdata then calls `ddsi_serdata_to_ser_ref` to fill a `CDRBlob` for the user.

## **Conclusion**

The serdata API in Cyclone DDS provides low-level control to publish and subscribe to raw serialized DDS data (including XCDR2 format). In summary:

* Serdata objects wrap serialized samples and are managed with functions like `from_sample`, `from_ser`, `to_sample`, `to_ser`, etc. They carry metadata such as *kind* (data vs. key), and are reference-counted.  
* Writing raw: Use `dds_writecdr`/`dds_forwardcdr` with a prepared `ddsi_serdata`. You must have the type registered (sertype known) and include the 4-byte XCDR2 header in the data. This lets you inject an XCDR2 serialized buffer directly into Cyclone’s writer path.  
* Reading raw: Use `dds_readcdr`/`dds_takecdr` to get `ddsi_serdata` samples from a reader. Then extract the bytes via serdata API. Remember to free the serdata with `ddsi_serdata_unref` when done.  
* Initialization: A proper topic (with type info) must exist – typically via IDL descriptors or dynamic types – before using these calls. Once set up, the serdata functions allow zero-copy or low-copy access to the data in XCDR2 format, which you can then manipulate as needed.

This provides a powerful mechanism to integrate Cyclone DDS with other systems that speak CDR, or to implement generic DDS tooling. Just take care of memory management (unref those serdatas\!) and ensure the XCDR headers/encoding are handled correctly. With that, you can read and write DDS samples at the byte level using Cyclone DDS’s serdata API. Sources:

* Cyclone DDS C API Reference – serialized data read/write functions (`dds_readcdr`, `dds_takecdr`, `dds_writecdr`)  
* Cyclone DDS Serdata internal API definitions (ZettaScale/CycloneDDS source) – showing serdata creation, conversion, and header usage  
* CycloneDDS C++ implementation (CycloneDDS-CXX) – examples of using serdata for raw data writing and reading  
* User discussion on topic creation and use of `dds_*cdr` APIs – emphasizing the need for type information.

Citations  
[ddsi\_serdata.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L73-L80)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi\_serdata.h\#L73-L80](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L73-L80)  
[AnyDataWriterDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L106-L114)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp\#L106-L114](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L106-L114)  
[ddsi\_serdata.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L116-L124)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi\_serdata.h\#L116-L124](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L116-L124)  
[ddsi\_serdata.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L92-L100)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi\_serdata.h\#L92-L100](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L92-L100)  
[ddsi\_serdata.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L100-L108)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi\_serdata.h\#L100-L108](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L100-L108)  
[ddsi\_serdata.c](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L38-L46)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi\_serdata.c\#L38-L46](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L38-L46)  
[ddsi\_serdata.c](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L68-L75)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi\_serdata.c\#L68-L75](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L68-L75)  
[ddsi\_serdata.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L150-L158)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi\_serdata.h\#L150-L158](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/include/dds/ddsi/ddsi_serdata.h#L150-L158)  
[dds.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L4550-L4558)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h\#L4550-L4558](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L4550-L4558)  
[ddsi\_serdata.c](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L82-L85)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi\_serdata.c\#L82-L85](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsi/src/ddsi_serdata.c#L82-L85)  
[dds.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L2494-L2502)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h\#L2494-L2502](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L2494-L2502)  
[dds.h](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L2515-L2523)  
[https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h\#L2515-L2523](https://github.com/eclipse-cyclonedds/cyclonedds/blob/c49206be5cfbe76de546e0adad172a0d80726f77/src/core/ddsc/include/dds/dds.h#L2515-L2523)  
[AnyDataWriterDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L116-L124)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp\#L116-L124](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L116-L124)  
[TopicDescriptionDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/topic/TopicDescriptionDelegate.cpp#L83-L89)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/topic/TopicDescriptionDelegate.cpp\#L83-L89](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/topic/TopicDescriptionDelegate.cpp#L83-L89)  
[AnyDataWriterDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L138-L146)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp\#L138-L146](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L138-L146)  
[AnyDataWriterDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L148-L155)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp\#L148-L155](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/pub/AnyDataWriterDelegate.cpp#L148-L155)  
[datatopic.hpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp#L36-L45)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp\#L36-L45](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp#L36-L45)  
[datatopic.hpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp#L36-L44)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp\#L36-L44](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/org/eclipse/cyclonedds/topic/datatopic.hpp#L36-L44)

[Function dds\_takecdr — Eclipse Cyclone DDS 0.9.1 documentation](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=Access%20the%20collection%20of%20serialized,data%20reader%2C%20readcondition%20or%20querycondition)  
[https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc\_api\_docs/function\_dds\_8h\_1a51aa237a2fc107aacbf2e9947339eb12.html](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=Access%20the%20collection%20of%20serialized,data%20reader%2C%20readcondition%20or%20querycondition)

[Function dds\_takecdr — Eclipse Cyclone DDS 0.9.1 documentation](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=This%20call%20accesses%20the%20serialized,be%20%E2%80%98read%E2%80%99%20or%20%E2%80%98taken%E2%80%99%20again)  
[https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc\_api\_docs/function\_dds\_8h\_1a51aa237a2fc107aacbf2e9947339eb12.html](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=This%20call%20accesses%20the%20serialized,be%20%E2%80%98read%E2%80%99%20or%20%E2%80%98taken%E2%80%99%20again)

[Function dds\_takecdr — Eclipse Cyclone DDS 0.9.1 documentation](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=made%20available%20through%20ddsi_serdata%20structures,be%20%E2%80%98read%E2%80%99%20or%20%E2%80%98taken%E2%80%99%20again)  
[https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc\_api\_docs/function\_dds\_8h\_1a51aa237a2fc107aacbf2e9947339eb12.html](https://cyclonedds.io/docs/cyclonedds/0.9.1/ddsc_api_docs/function_dds_8h_1a51aa237a2fc107aacbf2e9947339eb12.html#:~:text=made%20available%20through%20ddsi_serdata%20structures,be%20%E2%80%98read%E2%80%99%20or%20%E2%80%98taken%E2%80%99%20again)  
[SamplesHolder.hpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L82-L91)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp\#L82-L91](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L82-L91)  
[SamplesHolder.hpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L100-L103)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp\#L100-L103](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L100-L103)  
[SamplesHolder.hpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L80-L88)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp\#L80-L88](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/include/dds/sub/detail/SamplesHolder.hpp#L80-L88)  
[AnyDataReaderDelegate.cpp](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/sub/AnyDataReaderDelegate.cpp#L168-L176)  
[https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/sub/AnyDataReaderDelegate.cpp\#L168-L176](https://github.com/eclipse-cyclonedds/cyclonedds-cxx/blob/4404162be2ee4fbd2eedfe4c1a44cb3f0fb99264/src/ddscxx/src/org/eclipse/cyclonedds/sub/AnyDataReaderDelegate.cpp#L168-L176)

[How to use \`dds\_readcdr\` and \`dds\_writecdr\` on a topic without knowing the message type(i.e., no IDL given)? · Issue \#2099 · eclipse-cyclonedds/cyclonedds · GitHub](https://github.com/eclipse-cyclonedds/cyclonedds/issues/2099#:~:text=Note%20that%20,unknown%20for%20the%20generic%20gateway)  
[https://github.com/eclipse-cyclonedds/cyclonedds/issues/2099](https://github.com/eclipse-cyclonedds/cyclonedds/issues/2099#:~:text=Note%20that%20,unknown%20for%20the%20generic%20gateway)  