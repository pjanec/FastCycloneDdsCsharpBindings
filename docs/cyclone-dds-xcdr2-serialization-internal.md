# Cyclone DDS Serialization Internals

## ddsi\_sertype and ddsi\_serdata Overview

Cyclone DDS represents topic data internally using a **type object** \(`ddsi_sertype`\) and **serialized data objects** \(`ddsi_serdata`\). The `ddsi_sertype` holds meta-information for a topic’s type \(name, keys, type size/ops\), while each `ddsi_serdata` instance holds a sample’s serialized payload or key. Both are defined in C source \(not just documentation\) and include function tables \(“ops”\) for serialization routines. For example, `ddsi_serdata_ops` provides function pointers to create a serdata from a sample \(`from_sample`\), to convert serdata to raw bytes \(`to_ser`\), to compute key hash \(`get_keyhash`\), etc.. The `ddsi_sertype` for the default IDL types \(in *dds\_\_serdata\_default.h*\) embeds a base `ddsi_sertype` and specifies an `encoding_format` field \(e.g. `CDR_LE` vs `CDR2_LE`\) to denote XCDR version. This encoding format and associated flags determine whether samples use classic XCDR1 or XCDR2 encoding.
 
**Exposed vs. Internal:** The `ddsi_sertype`/`ddsi_serdata` API is considered internal \(subject to change\), but Cyclone does expose hooks to use them. Notably, `dds_create_topic_sertype()` lets an application supply a custom `ddsi_sertype` \(with its own ops\) for a new topic. Also, raw read/write APIs use `ddsi_serdata` directly. These hooks allow advanced integration of external serialization logic, even though the structures are primarily used internally.

## Write Path: `dds_write` vs `dds_writecdr`

**Standard writes \(`dds_write`\)** – When you write a typed sample, Cyclone converts it to a `ddsi_serdata` behind the scenes. Inside `dds_write_impl` \(see *dds\_write.c*\), the code locks the writer and calls `ddsi_serdata_from_sample` with the writer’s internal `ddsi_sertype` and the sample pointer. This function invokes the type-specific serializer \(from the `ddsi_serdata_ops` for that type\) to produce a serialized representation. For example, a user data struct is serialized to XCDR by the built-in CDR serializer \(`dds_serdata_ops_cdr`\). The call stack illustrates this flow: `dds_write_impl` → `ddsi_serdata_from_sample(...)` \(inlined in *ddsi\_serdata.h*\) → type’s `from_sample` op. If the sample represents a regular write, Cyclone passes `SDK_DATA` as the kind; for a dispose or unregister \(instance key only\), it uses `SDK_KEY`. On success, a `ddsi_serdata *` is returned and then enqueued into the writer for delivery.
 
**Raw writes \(`dds_writecdr`\)** – This API allows the application to supply a pre-serialized sample as a `ddsi_serdata` object. Internally, `dds_writecdr` bypasses the serialization step above. It still locks the writer, but since a `serdata` is provided, Cyclone can directly use it. The implementation calls essentially the same enqueue logic as a normal write, but without invoking `from_sample`. \(In older versions this was called `dds_forwardcdr` with identical behavior.\) The `dds_writecdr` operation writes the given `serdata` **unchanged** into the DataWriter; no additional transforms occur as long as the `ddsi_sertype` matches the writer’s topic. This means if you have an external source producing XCDR2 bytes, you can wrap them in a `ddsi_serdata` and use `dds_writecdr` to send them without Cyclone re-serializing.
 
**Note:** The writer’s topic type must correspond to the `ddsi_serdata`’s type. Cyclone will forward the data unchanged only if the writer’s and reader’s types match; otherwise it might fall back to re-serialize or fail.

## Read Path: `dds_takecdr` and Serdata Handling

For reading, Cyclone offers `dds_takecdr`, which provides raw serialized samples. When you call `dds_takecdr` on a DataReader, it pulls data from the reader’s history and returns an array of `ddsi_serdata*` rather than decoded sample structs. Internally, this calls the same cache logic as `dds_take`, but instead of converting to user data, the samples remain in their serialized form. The returned `ddsi_serdata` objects reference the reader’s `ddsi_sertype` so you know how to interpret the bytes. Importantly, `dds_takecdr` **removes** those samples from the reader cache \(just like a normal take\). The caller is responsible for eventually releasing each serdata by calling `ddsi_serdata_unref()` once done. This design allows zero-copy data handling – e.g. a bridge can take the `ddsi_serdata` from one reader and directly `dds_writecdr` it out another writer, without ever touching the actual user fields.
 
**Key extraction on read:** If the reader is keyed, the `ddsi_serdata` still contains or can produce the key. The `ddsi_serdata_ops->get_keyhash` function can be used to obtain the key’s 16-byte hash or value from the serdata. \(Cyclone’s default implementation will compute this on demand as described below.\) The `dds_sample_info` returned alongside can also include the actual instance handle or key value for identification.

## XCDR1 vs. XCDR2 Detection & Handling

Cyclone DDS supports both XCDR version 1 \(classic CDR\) and XCDR2 \(with OMG XTypes\). The determination of which encoding to use is made at type creation and during handshake with peers:

- **Type Description Flags:** The IDL compiler populates the topic descriptor’s flagset \(`m_flagset`\) with indicators like `DDS_TOPIC_XTYPES_METADATA` \(meaning XTypes info is available\) and data representation restrictions. Notably, if XTypes metadata is present for a type, Cyclone’s default `ddsi_sertype` is configured to use XCDR2 encoding by default. The internal `dds_sertype_default` structure has an `encoding_format` field which Cyclone sets to the appropriate constant for XCDR1 vs XCDR2 \(e.g. `CDR_LE` vs `CDR2_LE`\). In effect, when a topic is created, the code decides the encoding: if the type has XTypes \(minimal/complete TypeObject\) or the user restricted representation to XCDR2, it will set `encoding_format = CDR2_*` in the sertype; otherwise it uses classic CDR.
- **DataRepresentation QoS:** At the DDSI network level, Cyclone will negotiate the data representation between writer and reader. By default, Cyclone allows both XCDR1 and XCDR2 \(unless `DDS_TOPIC_RESTRICT_DATA_REPRESENTATION` is set\). If a reader only supports XCDR1, the writer can fall back. The actual encoding used for a given writer is stored in its `ddsi_sertype.encoding_format`. In logs or debug, one can see the writer uses `dds_serdata_ops_cdr` \(for XCDR1\) unless switched to `CDR2_LE` in the sertype \(there is currently no public API to toggle this at runtime, it’s chosen by Cyclone based on type info and QoS\).
- **Payload Inspection:** When receiving data, Cyclone can also inspect the RTPS encapsulation header. XCDR2-encoded data carries a different encapsulation ID in the first 4 bytes of the payload \(e.g. `0x0003xxxx` for PL\_CDR2\). The internal deserialization routines check these headers to decide how to parse the payload. In fact, the default `ddsi_serdata_from_ser` implementation will look at the CDR header to detect if it’s a little-endian XCDR1 \(`0x0001`\) vs. XCDR2 \(`0x0021` etc.\) and will create the appropriate serdata variant.

In summary, **Cyclone uses XCDR2 whenever possible** – if both endpoints support it – falling back to XCDR1 for compatibility. The choice is made per topic type and recorded in the sertype. There isn’t a simple config switch exposed to the user as of v0.11; it’s managed by the presence of type metadata and the Data Representation QoS negotiation. \(Issue #2077 confirms that by default Cyclone uses CDR\_LE \(XCDR1\) for IDL types without XTypes metadata, and switching to CDR2 requires the type/object to be provided in XTypes form or using the raw CDR APIs.\)

## Key Hash Computation and Composite Keys

For keyed topics, Cyclone must compute a 128-bit **key hash** \(used for instance identification in DDSI\). Internally this is done via the `get_keyhash` op in the `ddsi_serdata_ops`. In the default implementation, the logic follows the DDS specification’s rules:

- If the serialized key \(all key fields\) **fits in 16 bytes or less**, Cyclone will use the **serialized key bytes directly** as the 16-byte key hash \(padding with zeros as needed\). This avoids an expensive hash when keys are small \(e.g. a single 32-bit key fits in 4 bytes, so it would just place those 4 bytes in the hash and zero the rest\).
- If the key’s serialized size is **larger than 16 bytes**, Cyclone will compute an **MD5 hash** of the key’s XCDR representation and use that. This is per the DDSI spec for KeyHash \(MD5 for large keys\).
- Cyclone’s code distinguishes XCDR1 vs XCDR2 alignment for keys. There are separate flags `DDS_TOPIC_FIXED_KEY` and `DDS_TOPIC_FIXED_KEY_XCDR2` in the topic descriptor. These are set at compile-time if it’s known that the key fields always occupy ≤16 bytes in the given encoding. For example, due to XCDR2’s 8-byte alignment rules, a key might be 16 bytes in XCDR1 but 20 bytes in XCDR2 \(hence one flag could be true while the other false\). The `get_keyhash` implementation uses these flags to decide if it can treat the key as fixed-size. If the appropriate fixed-key flag is set, Cyclone knows the key hash is just the serialized key \(no MD5\). Otherwise, it will serialize the key fields \(or use an already serialized key representation\) and run MD5.
- **Where in code:** When a serdata is created from a sample \(`from_sample`\), the key may be computed immediately for efficiency. For instance, Cyclone’s IDL serializer can generate the key bytes alongside the full sample serialization if keys are defined. In other cases, `get_keyhash` might serialize only the key fields on demand. In the `ddsi_serdata_ops_cdr` \(default\), the `to_ser` function can produce either an **entire sample** or **key-only** serialization depending on the serdata kind \(SDK\_DATA vs SDK\_KEY\). Thus, `get_keyhash` can leverage the key-only serialization path. The ops structure even provides a `from_keyhash` to reconstruct a serdata from just a key hash \(used for disposes/unregisters where only the key hash was received\).

For composite keys \(multiple key fields\), the process is the same – all key fields are concatenated in the XCDR encoding order. If their total exceeds 16 bytes, MD5 is applied. If not, the bytes \(including any padding in XCDR\) are used directly as the hash. Cyclone’s implementation thus fully complies with the DDSI specification for key hashes.

## Extending for External XCDR2 Serializers

**Integrating a custom serializer/deserializer** \(e.g. to plug in an alternate XCDR2 pipeline or a third-party serialization format\) is possible via Cyclone’s pluggable typesupport API:

- You can **implement your own `ddsi_sertype`** with a matching set of `ddsi_serdata_ops`. For example, ROS 2 does this to use its CDR serialization – a custom `sertype` \(“serdata\_rmw”\) implements `from_sample` to call ROS 2’s serializer and fill a `ddsi_serdata` with the resulting byte stream. Similarly, you would implement ops: `from_sample` \(serialize your data into a buffer\), `to_sample` \(deserialize into a sample, if needed\), `from_ser` \(construct serdata from raw bytes received\), etc., as well as `get_keyhash` if the type is keyed.
- Use **`dds_create_topic_sertype()`** to create a DDS Topic with your custom type support. You pass in your `ddsi_sertype` object; Cyclone will take ownership if the topic is created successfully. All DataWriters/DataReaders for that topic will then use your provided serialization ops. This is the cleanest way to hook in external XCDR2 handling – you essentially override how Cyclone serializes that topic’s data. Your sertype should specify the correct `encoding_format` \(e.g. set to XCDR2\) so that Cyclone advertises the proper representation to peers.
- Internally, Cyclone will treat your custom serdata the same as its own. You can still use `dds_write` \(which will call your `from_sample`\), or use `dds_writecdr` if you manually create `ddsi_serdata` objects via your ops. On the read side, `dds_takecdr` will yield your custom `ddsi_serdata` objects, which you can interpret using your own logic. If you prefer to hand the bytes off elsewhere, you can just forward the serdata as-is.
- **File/function references for guidance:** The built-in implementation in *src/core/ddsc/src/dds\_\_serdata\_default.c* \(and `.h`\) is a good template. It defines `dds_serdata_ops_cdr` for the standard IDL types. Key functions to examine are the static implementations of `from_sample`, `to_ser`, and `get_keyhash` in that file – these show how Cyclone serializes/deserializes XCDR data and computes key hashes. For instance, the code checks the fixed-key flags and length when implementing `get_keyhash` \(see comments in *serialization.md* about 16-byte keys\). By mimicking that structure, you ensure your custom ops integrate correctly.
- If you need to modify Cyclone’s internals \(not usually necessary\), one could adjust how the default sertype chooses XCDR2. In *dds\_\_serdata\_default.c*, the `new_sertype_default()` function \(which creates a `dds_sertype_default`\) uses the presence of XTypes metadata to decide `encoding_format`. For testing, one could force `st->encoding_format = CDR2_LE` unconditionally to prefer XCDR2. Similarly, setting the topic descriptor’s `m_flagset` to include `DDS_TOPIC_XTYPES_METADATA` will signal Cyclone to use XCDR2 for that type. However, the recommended approach is to use the official hooks rather than patching the library.

**Summary of Recommendations:** Use `dds_create_topic_sertype` with a custom `ddsi_sertype` to inject external XCDR2 serialization. Implement the required ops in a similar fashion to Cyclone’s default \(files *ddsi\_serdata.h* and *dds\_\_serdata\_default.h/c* contain the function signatures and examples\). Ensure your ops correctly handle key hashing \(perhaps by using Cyclone’s MD5 utilities and following the 16-byte rule\). By doing so, you can cleanly integrate an external serializer such that `dds_write` and `dds_take` in Cyclone will defer to your logic, while still allowing zero-copy transfer via `dds_writecdr`/`dds_takecdr` using `ddsi_serdata` objects.
 
**Relevant Source References:**

- Definition of topic descriptor flags and XCDR constants in `dds_public_impl.h` \(e.g. `DDS_DATA_REPRESENTATION_XCDR2`\) and topic flags like `DDS_TOPIC_FIXED_KEY(_XCDR2)`.
- Declaration of `ddsi_serdata_ops` with serialization function pointers in `ddsi_serdata.h`.
- Implementation call chain for writing: `dds_write` → `dds_write_impl` → `ddsi_serdata_from_sample` \(see *dds\_write.c* and *ddsi\_serdata.h*\).
- API docs showing `dds_writecdr` signature \(takes `ddsi_serdata*`\) and `dds_takecdr` returning serdata buffers.
- Guidance on releasing serdata \(`ddsi_serdata_unref`\) after `dds_takecdr`.
- Creation of custom topic with user sertype: `dds_create_topic_sertype` definition in *dds.h*.

These source references confirm how serialized XCDR2 data flows through Cyclone’s write/read path and where you can hook in to extend or modify it as needed. By leveraging the provided extension points instead of altering core logic, one can integrate external XCDR2 serialization cleanly while maintaining compatibility with Cyclone DDS’s internal model.