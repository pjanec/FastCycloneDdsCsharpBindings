# CDR Serialization and Native Binding Discoveries

## Overview
This document summarizes recent findings regarding Common Data Representation (CDR) serialization, native CycloneDDS bindings, and the interaction between C# and the native `ddsc` library. These discoveries are critical for resolving serialization issues with Keyed Topics and Extensible Types (XTypes).

## Key Discoveries

### 1. The 4-Byte CDR Header
*   **Native Structure**: The native `ddsi_serdata_cdr` structure (defined in `ddsi_serdata_cdr.c`) includes a `struct dds_cdr_header hdr` at the very beginning of the data block.
*   **Size**: This header is **4 bytes**.
*   **Content**: It typically contains the encapsulation identifier (e.g., `DDSI_RTPS_CDR_LE` = 0x0001) and options (padding/endianness).
*   **Serialization**: When converting `serdata` to a serialized blob (`serdata_cdr_to_ser`), this header is explicitly copied first.
*   **Deserialization**: When creating `serdata` from a blob (`serdata_cdr_from_ser`), the function `serdata_cdr_from_ser_common` **skips the first 4 bytes** (`uint32_t off = 4;`) before processing the rest of the data using the fragment chain.

### 2. `DDS_OP_DLC` Instruction
*   **Meaning**: `DDS_OP_DLC` (0x04000000) likely stands for "Data Length Code" or similar. It appears in the `_ops` array generated by `idlc` for types marked as `@appendable` or `@mutable`.
*   **Function**: It instructs the interpreter that the data is prefixed with a length or header.
*   **Interaction with Keys**:
    *   If `DDS_OP_DLC` is present, the native key extractor might expect the data to be structured differently (e.g., with a DHEADER).
    *   If we strip `DDS_OP_DLC` from the `_ops` array but pass a buffer *with* a header, the interpreter (using `DDS_OP_ADR` at offset 0) will read the header bytes as if they were the first field of the struct. This causes data corruption and key mismatch.

### 3. `dds_create_serdata_from_cdr` Behavior
*   **Input**: Takes a `dds_topic_descriptor_t` and a buffer.
*   **Process**: It creates a `serdata` object (likely `ddsi_serdata_cdr` or `dds_serdata_default`).
*   **Validation**: It appears to validate the buffer size against the descriptor.
*   **Crash Cause**: The error `dds_create_serdata_from_cdr failed` often indicates a size mismatch or an inability to parse the data according to the provided `_ops`.
    *   If `_ops` has `DDS_OP_DLC`, it might expect a specific header/length.
    *   If `_ops` does *not* have `DDS_OP_DLC`, it expects raw struct data.
    *   If we pass a buffer with a 4-byte header but strip `DDS_OP_DLC` (and don't shift offsets), the size check might pass (if `m_size` is ignored or matches), but the content interpretation will be wrong.

### 4. `DdsWriter` Serialization
*   **Current C# Implementation**:
    *   Prepends a 4-byte header (`0x00010000` for LE CDR) to the buffer.
    *   Writes the struct data.
    *   Passes this combined buffer (Header + Data) to `dds_create_serdata_from_cdr`.
*   **Mismatch**:
    *   If the generated `_ops` (from `idlc`) *expect* this header (via `DDS_OP_DLC`), it should work.
    *   If `idlc` generates `DDS_OP_DLC` only for `@appendable`, but we treat everything as `@appendable`, we might have a consistency issue if the `_ops` don't match our serialization format.

### 5. `DdsParticipant` Descriptor
*   **`m_size`**: The `dds_topic_descriptor_t` has an `m_size` field.
    *   For fixed-size types (`@final`), this is the struct size.
    *   For variable-size types (`@appendable`, `@mutable`, strings, sequences), this should likely be 0 or ignored by the native parser to avoid strict size checks against the serialized blob (which varies).
    *   Setting `m_size = 0` when `DDS_TOPIC_FIXED_SIZE` is not set is a potential fix for size validation errors.

## Hypothesis & Next Steps
*   **Hypothesis**: The native `dds_create_serdata_from_cdr` expects the buffer to match the `_ops`.
    *   If `_ops` starts with `DDS_OP_DLC`, it handles the header/length.
    *   If we strip `DDS_OP_DLC`, we **MUST** shift all `DDS_OP_ADR` offsets by 4 bytes to skip the header we prepended in `DdsWriter`.
    *   Alternatively, we could stop prepending the header in `DdsWriter` if we strip `DDS_OP_DLC`, but the native reader likely *needs* that header for `serdata` management (as seen in `ddsi_serdata_cdr.c`).
*   **Action**:
    *   The most robust approach seems to be: **Keep the header in `DdsWriter`**, **Strip `DDS_OP_DLC`** (to avoid native confusion if it's buggy or we misuse it), and **Shift Offsets by 4** to align `_ops` with the data payload (skipping the header).
    *   We also need to ensure `m_size` in the descriptor doesn't conflict with the total buffer size (Header + Data).

## References
*   `cyclonedds/src/core/ddsi/src/ddsi_serdata_cdr.c`
*   `cyclonedds/src/core/ddsc/src/dds_serdata_default.c`
