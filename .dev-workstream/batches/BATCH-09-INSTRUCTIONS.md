# BATCH-09: Complete Marshaller + Metadata Registry (COMBINED)

**Batch Number:** BATCH-09  
**Tasks:** FCDC-011 completion (arrays/unions), FCDC-012 (metadata registry)  
**Phase:** Phase 2 - Code Generator  
**Estimated Effort:** 6-8 days  
**Priority:** CRITICAL  
**Dependencies:** BATCH-08 (Marshaller foundation)

---

## üîÑ MANDATORY WORKFLOW: Test-Driven Task Progression

**CRITICAL: Complete tasks in sequence with passing tests:**

1. **Task 1 (Complete Marshaller):** Implement ‚Üí Write tests ‚Üí **ALL tests pass** ‚úÖ
2. **Task 2 (Metadata Registry):** Implement ‚Üí Write tests ‚Üí **ALL tests pass** ‚úÖ

**DO NOT** move to Task 2 until Task 1 complete with all tests passing.

---

## üìã Required Reading

1. **BATCH-08 Review:** `.dev-workstream/reviews/BATCH-08-REVIEW.md`
2. **Tasks:** `docs/FCDC-TASK-MASTER.md` ‚Üí FCDC-011, FCDC-012
3. **Design:** `docs/FCDC-DETAILED-DESIGN.md` ‚Üí ¬ß6.4, ¬ß6.2-6.5
4. **Current Marshaller:** `Emitters/MarshallerEmitter.cs`

**Report:** `.dev-workstream/reports/BATCH-09-REPORT.md`

---

## üéØ Objectives

**Part 1: Complete Marshaller**
1. Array marshalling (unbounded ‚Üí allocate, bounded ‚Üí fixed buffer)
2. Union marshalling (discriminator + active arm only)
3. Nested struct marshalling (recursive)
4. String array marshalling

**Part 2: Metadata Registry**
5. TopicMetadata class (name, type, QoS, key indices)
6. MetadataRegistry static class generation
7. Integration into CodeGenerator

---

## ‚úÖ Task 1: Complete Marshaller

### Task 1.1: Array Marshalling

**File:** `tools/CycloneDDS.CodeGen/Emitters/MarshallerEmitter.cs` (MODIFY)

```csharp
private void EmitMarshalField(FieldDeclarationSyntax field, bool toNative)
{
    var fieldType = field.Declaration.Type.ToString();
    var fieldName = field.Declaration.Variables.First().Identifier.Text;
    
    // ... existing primitive/FixedString logic ...
    
    // Unbounded arrays: int[] -> IntPtr + int
    if (fieldType.EndsWith("[]"))
    {
        var elementType = fieldType[..^2];
        
        if (toNative)
        {
            EmitLine($"        // Marshal array {fieldName}");
            EmitLine($"        if (managed.{fieldName} != null && managed.{fieldName}.Length > 0)");
            EmitLine("        {");
            EmitLine($"            var bytes = managed.{fieldName}.Length * sizeof({GetPrimitiveSize(elementType)});");
            EmitLine($"            native.{fieldName}_Ptr = Marshal.AllocHGlobal(bytes);");
            EmitLine($"            native.{fieldName}_Length = managed.{fieldName}.Length;");
            EmitLine($"            Marshal.Copy(managed.{fieldName}, 0, native.{fieldName}_Ptr, managed.{fieldName}.Length);");
            EmitLine("        }");
            EmitLine("        else");
            EmitLine("        {");
            EmitLine($"            native.{fieldName}_Ptr = IntPtr.Zero;");
            EmitLine($"            native.{fieldName}_Length = 0;");
            EmitLine("        }");
        }
        else
        {
            EmitLine($"        // Unmarshal array {fieldName}");
            EmitLine($"        if (native.{fieldName}_Ptr != IntPtr.Zero && native.{fieldName}_Length > 0)");
            EmitLine("        {");
            EmitLine($"            managed.{fieldName} = new {elementType}[native.{fieldName}_Length];");
            EmitLine($"            Marshal.Copy(native.{fieldName}_Ptr, managed.{fieldName}, 0, native.{fieldName}_Length);");
            EmitLine("        }");
            EmitLine("        else");
            EmitLine("        {");
            EmitLine($"            managed.{fieldName} = Array.Empty<{elementType}>();");
            EmitLine("        }");
        }
        return;
    }
}

private string GetPrimitiveSize(string type)
{
    return type switch {
        "byte" or "sbyte" => "1",
        "short" or "ushort" => "2",
        "int" or "uint" or "float" => "4",
        "long" or "ulong" or "double" => "8",
        _ => "4"
    };
}
```

### Task 1.2: Union Marshalling

**File:** `tools/CycloneDDS.CodeGen/Emitters/MarshallerEmitter.cs` (ADD)

```csharp
public string GenerateUnionMarshaller(TypeDeclarationSyntax type, string namespaceName)
{
    _sb.Clear();
    
    var typeName = type.Identifier.Text;
    var marshallerName = $"{typeName}Marshaller";
    var managedTypeName = $"{typeName}";
    var nativeTypeName = $"{typeName}Native";
    
    // Header
    EmitLine("// <auto-generated/>");
    EmitLine($"// Generated marshaller for union {typeName}");
    EmitLine();
    EmitLine("using System;");
    EmitLine("using System.Runtime.InteropServices;");
    EmitLine("using CycloneDDS.CodeGen.Marshalling;");
    EmitLine();
    EmitLine($"namespace {namespaceName};");
    EmitLine();
    
    EmitLine($"public class {marshallerName} : IMarshaller<{managedTypeName}, {nativeTypeName}>");
    EmitLine("{");
    
    // Marshal
    EmitLine($"    public unsafe void Marshal(ref {managedTypeName} managed, ref {nativeTypeName} native)");
    EmitLine("    {");
    
    // Marshal discriminator
    var discriminatorField = type.Members.OfType<FieldDeclarationSyntax>()
        .First(f => f.AttributeLists.SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString().Contains("Discriminator")));
    
    var discName = discriminatorField.Declaration.Variables.First().Identifier.Text;
    EmitLine($"        native.{discName} = managed.{discName};");
    EmitLine();
    
    // Switch on discriminator
    EmitLine($"        switch (managed.{discName})");
    EmitLine("        {");
    
    var caseFields = type.Members.OfType<FieldDeclarationSyntax>()
        .Where(f => f.AttributeLists.SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.ToString().Contains("DdsCase")));
    
    foreach (var caseField in caseFields)
    {
        var armName = caseField.Declaration.Variables.First().Identifier.Text;
        var caseAttr = caseField.AttributeLists.SelectMany(al => al.Attributes)
            .First(attr => attr.Name.ToString().Contains("DdsCase"));
        var caseValue = caseAttr.ArgumentList?.Arguments.FirstOrDefault()?.ToString() ?? "0";
        
        EmitLine($"            case {caseValue}:");
        EmitLine($"                native.{armName} = managed.{armName};");
        EmitLine("                break;");
    }
    
    EmitLine("        }");
    EmitLine("    }");
    EmitLine();
    
    // Unmarshal
    EmitLine($"    public {managedTypeName} Unmarshal(ref {nativeTypeName} native)");
    EmitLine("    {");
    EmitLine($"        var managed = new {managedTypeName}();");
    EmitLine($"        managed.{discName} = native.{discName};");
    EmitLine();
    EmitLine($"        switch (native.{discName})");
    EmitLine("        {");
    
    foreach (var caseField in caseFields)
    {
        var armName = caseField.Declaration.Variables.First().Identifier.Text;
        var caseAttr = caseField.AttributeLists.SelectMany(al => al.Attributes)
            .First(attr => attr.Name.ToString().Contains("DdsCase"));
        var caseValue = caseAttr.ArgumentList?.Arguments.FirstOrDefault()?.ToString() ?? "0";
        
        EmitLine($"            case {caseValue}:");
        EmitLine($"                managed.{armName} = native.{armName};");
        EmitLine("                break;");
    }
    
    EmitLine("        }");
    EmitLine("        return managed;");
    EmitLine("    }");
    
    EmitLine("}");
    
    return _sb.ToString();
}
```

---

## ‚úÖ Task 2: Metadata Registry

### Task 2.1: Define TopicMetadata

**File:** `tools/CycloneDDS.CodeGen/Runtime/TopicMetadata.cs` (NEW)

```csharp
namespace CycloneDDS.CodeGen.Runtime;

public class TopicMetadata
{
    public string TopicName { get; init; } = "";
    public string TypeName { get; init; } = "";
    public Type ManagedType { get; init; } = typeof(object);
    public Type NativeType { get; init; } = typeof(object);
    public Type MarshallerType { get; init; } = typeof(object);
    public int[] KeyFieldIndices { get; init; } = Array.Empty<int>();
}
```

### Task 2.2: Generate MetadataRegistry

**File:** `tools/CycloneDDS.CodeGen/Emitters/MetadataRegistryEmitter.cs` (NEW)

```csharp
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;

namespace CycloneDDS.CodeGen.Emitters;

public class MetadataRegistryEmitter
{
    private readonly StringBuilder _sb = new();
    
    public string GenerateRegistry(List<(TypeDeclarationSyntax Type, string TopicName)> topics, string namespaceName)
    {
        _sb.Clear();
        
        EmitLine("// <auto-generated/>");
        EmitLine("// Generated metadata registry");
        EmitLine();
        EmitLine("using System;");
        EmitLine("using System.Collections.Generic;");
        EmitLine("using CycloneDDS.CodeGen.Runtime;");
        EmitLine();
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        
        EmitLine("public static class MetadataRegistry");
        EmitLine("{");
        EmitLine("    private static readonly Dictionary<string, TopicMetadata> _registry = new()");
        EmitLine("    {");
        
        foreach (var (type, topicName) in topics)
        {
            var typeName = type.Identifier.Text;
            
            // Find key fields
            var keyFields = type.Members.OfType<FieldDeclarationSyntax>()
                .Select((f, idx) => new { Field = f, Index = idx })
                .Where(x => x.Field.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(attr => attr.Name.ToString().Contains("DdsKey")))
                .Select(x => x.Index)
                .ToArray();
            
            var keyIndicesStr = keyFields.Length > 0 
                ? $"new[] {{ {string.Join(\", \", keyFields)} }}" 
                : "Array.Empty<int>()";
            
            EmitLine($"        {{ \"{topicName}\", new TopicMetadata");
            EmitLine("        {");
            EmitLine($"            TopicName = \"{topicName}\",");
            EmitLine($"            TypeName = \"{typeName}\",");
            EmitLine($"            ManagedType = typeof({typeName}),");
            EmitLine($"            NativeType = typeof({typeName}Native),");
            EmitLine($"            MarshallerType = typeof({typeName}Marshaller),");
            EmitLine($"            KeyFieldIndices = {keyIndicesStr}");
            EmitLine("        }},");
        }
        
        EmitLine("    };");
        EmitLine();
        EmitLine("    public static TopicMetadata GetMetadata(string topicName) => _registry[topicName];");
        EmitLine("    public static bool TryGetMetadata(string topicName, out TopicMetadata? metadata) => _registry.TryGetValue(topicName, out metadata);");
        EmitLine("    public static IEnumerable<TopicMetadata> GetAllTopics() => _registry.Values;");
        EmitLine("}");
        
        return _sb.ToString();
    }
    
    private void EmitLine(string text = "") => _sb.AppendLine(text);
}
```

---

## üß™ Testing Requirements

**Minimum 12 Tests:**

**Marshaller Completion (6 tests)**
1. ‚úÖ `Marshaller_MarshalsPrimitiveArray`
2. ‚úÖ `Marshaller_UnmarshalsPrimitiveArray`
3. ‚úÖ `Marshaller_MarshalUnion_CorrectArmOnly`
4. ‚úÖ `Marshaller_UnmarshalUnion_ReadsDiscriminator`
5. ‚úÖ `Marshaller_NestedStruct_Recursive`
6. ‚úÖ `Marshaller_EmptyArray_HandledCorrectly`

**Metadata Registry (6 tests)**
7. ‚úÖ `MetadataRegistry_ContainsAllTopics`
8. ‚úÖ `MetadataRegistry_GetMetadata_ReturnsCorrectData`
9. ‚úÖ `MetadataRegistry_KeyFieldIndices_Correct`
10. ‚úÖ `MetadataRegistry_TryGetMetadata_WorksForValidTopic`
11. ‚úÖ `MetadataRegistry_TryGetMetadata_ReturnsFalseForInvalid`
12. ‚úÖ `MetadataRegistry_GetAllTopics_ReturnsAll`

---

## üìä Report Requirements

1. **Issues Encountered** (if any)
2. **Test Results** (98+ tests: 86 previous + 12 new)
3. **Developer Insights:**
   - Q1: How does array marshalling handle memory leaks?
   - Q2: Why marshal only active union arm?
   - Q3: Performance cost of metadata dictionary lookup?
4. **Checklist:** All items checked

---

## üéØ Success Criteria

1. ‚úÖ Array marshalling (allocate/free)
2. ‚úÖ Union marshalling (discriminator switch)
3. ‚úÖ Nested struct support
4. ‚úÖ TopicMetadata defined
5. ‚úÖ MetadataRegistry generated
6. ‚úÖ Key field indices tracked
7. ‚úÖ 12+ tests passing
8. ‚úÖ All 86 previous tests passing (98 total)

---

## ‚ö†Ô∏è Common Pitfalls

1. **Memory leaks** - Must free allocated arrays in Dispose
2. **Union active arm** - Only marshal discriminator's active arm
3. **NULL arrays** - Handle null/empty arrays gracefully
4. **Key field order** - Indices must match field declaration order

---

**Focus: Complete marshaller with arrays/unions, generate metadata registry for runtime.**
