# BATCH-06: Native Type Code Emitter (Part 1 - Structs Only)

**Batch Number:** BATCH-06  
**Tasks:** FCDC-009 (Native Type Emitter - Structs only, defer unions)  
**Phase:** Phase 2 - Code Generator  
**Estimated Effort:** 4-5 days  
**Priority:** CRITICAL  
**Dependencies:** BATCH-05 (Alignment Calculator)

---

## üìã Onboarding & Workflow

### Developer Instructions

This batch implements **native type generation** for struct-based topic types. You'll generate TNative blittable structs with `[StructLayout(LayoutKind.Sequential)]`, fixed buffers for arrays, and explicit field offsets.

**IMPORTANT:** This batch focuses on **STRUCTS ONLY**. Unions are deferred to BATCH-07 due to complexity (explicit layout, discriminators, payload alignment).

### Required Reading (IN ORDER)

1. **Workflow Guide:** `.dev-workstream/README.md`
2. **Task Definition:** `docs/FCDC-TASK-MASTER.md` ‚Üí See FCDC-009
3. **Design Document:** `docs/FCDC-DETAILED-DESIGN.md` ‚Üí ¬ß8 Type System, ¬ß5.1 Phase 4
4. **Previous Review:** `.dev-workstream/reviews/BATCH-05-REVIEW.md` - Layout calculator available
5. **BATCH-05 Code:** Review `Layout/StructLayoutCalculator.cs` - You'll use this!

### Source Code Location

- **Primary Work Area:** `tools/CycloneDDS.CodeGen/`
- **Test Project:** `tests/CycloneDDS.CodeGen.Tests/`

### Report Submission

**When done, create:**  
`.dev-workstream/reports/BATCH-06-REPORT.md`

---

## üéØ Objectives

Generate TNative blittable struct types from validated C# schemas:

1. **Sequential Layout** - Emit `[StructLayout(LayoutKind.Sequential)]` with Pack=1
2. **Primitive Fields** - Map C# primitives to blittable fields
3. **Fixed Buffers** - Use `fixed byte FieldName[N]` for FixedString/bounded arrays
4. **Pointer Fields** - Use `IntPtr` for unbounded strings/sequences (with length field)
5. **Nested Structs** - Handle nested user-defined types
6. **Unmanaged Constraint** - Ensure `where TNative : unmanaged`
7. **Integration** - Wire into CodeGenerator after IDL emission

---

## ‚úÖ Tasks

### Task 1: Implement Native Type Emitter

**File:** `tools/CycloneDDS.CodeGen/Emitters/NativeTypeEmitter.cs` (NEW)

Generates TNative structs from topic types:

```csharp
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CycloneDDS.CodeGen.Layout;
using CycloneDDS.CodeGen.Emitters;

namespace CycloneDDS.CodeGen.Emitters;

public class NativeTypeEmitter
{
    private readonly StringBuilder _sb = new();
    private readonly StructLayoutCalculator _layoutCalc = new();
    
    /// <summary>
    /// Generate TNative blittable struct from topic type.
    /// </summary>
    public string GenerateNativeStruct(TypeDeclarationSyntax type, string namespaceName)
    {
        _sb.Clear();
        
        var typeName = type.Identifier.Text;
        var nativeTypeName = $"{typeName}Native";
        
        // File header
        EmitLine("// <auto-generated/>");
        EmitLine($"// Generated native type for {typeName}");
        EmitLine();
        EmitLine("using System;");
        EmitLine("using System.Runtime.InteropServices;");
        EmitLine();
        
        // Namespace
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        
        // Calculate layout
        var layout = _layoutCalc.CalculateLayout(type);
        
        // Struct declaration
        EmitLine($"/// <summary>");
        EmitLine($"/// Native blittable representation of {typeName}.");
        EmitLine($"/// Total size: {layout.TotalSize} bytes, alignment: {layout.MaxAlignment} bytes");
        EmitLine($"/// </summary>");
        EmitLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        EmitLine($"public unsafe struct {nativeTypeName}");
        EmitLine("{");
        
        // Emit fields
        var fields = type.Members.OfType<FieldDeclarationSyntax>().ToList();
        foreach (var (field, fieldLayout) in fields.Zip(layout.Fields))
        {
            EmitField(field, fieldLayout);
        }
        
        EmitLine("}");
        
        return _sb.ToString();
    }
    
    private void EmitField(FieldDeclarationSyntax field, FieldLayout layout)
    {
        var fieldType = field.Declaration.Type.ToString();
        var fieldName = field.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "unknown";
        
        // Comment with layout info
        EmitLine($"    /// <summary>Offset: {layout.Offset}, Size: {layout.Size}, Align: {layout.Alignment}</summary>");
        
        // Map to native type
        var nativeType = MapToNativeType(fieldType, out var isFixedBuffer, out var bufferSize);
        
        if (isFixedBuffer)
        {
            // Fixed buffer: fixed byte FieldName[32];
            EmitLine($"    public fixed {nativeType} {fieldName}[{bufferSize}];");
        }
        else
        {
            // Regular field
            EmitLine($"    public {nativeType} {fieldName};");
        }
        
        EmitLine();
    }
    
    /// <summary>
    /// Map C# schema type to native blittable type.
    /// </summary>
    private string MapToNativeType(string csType, out bool isFixedBuffer, out int bufferSize)
    {
        isFixedBuffer = false;
        bufferSize = 0;
        
        // Primitives
        if (csType is "byte" or "sbyte" or "short" or "ushort" or 
                       "int" or "uint" or "long" or "ulong" or 
                       "float" or "double" or "bool")
        {
            return csType;
        }
        
        // Fixed strings
        if (csType.StartsWith("FixedString"))
        {
            isFixedBuffer = true;
            bufferSize = csType switch
            {
                "FixedString32" => 32,
                "FixedString64" => 64,
                "FixedString128" => 128,
                _ => 32 // default
            };
            return "byte"; // fixed byte array
        }
        
        // Special types (Guid, DateTime)
        if (csType is "Guid" or "System.Guid")
        {
            isFixedBuffer = true;
            bufferSize = 16;
            return "byte";
        }
        
        if (csType is "DateTime" or "System.DateTime")
        {
            return "long"; // Int64 ticks
        }
        
        // Quaternion
        if (csType.Contains("Quaternion"))
        {
            // Need to emit nested struct QuaternionF32x4
            // For now, assume it's defined elsewhere
            return "QuaternionF32x4";
        }
        
        // Unbounded string - pointer + length
        if (csType == "string")
        {
            // TODO: This needs special handling - return IntPtr for now
            // Real implementation needs TWO fields: IntPtr ptr + int length
            return "IntPtr"; // WARNING: Incomplete, needs length field too
        }
        
        // Arrays: int[] -> need pointer + length
        if (csType.EndsWith("[]"))
        {
            // TODO: Similar to string - needs IntPtr + int length
            return "IntPtr";
        }
        
        // BoundedSeq<T, N>
        if (csType.StartsWith("BoundedSeq<"))
        {
            // Extract T and N
            // For now, assume it's InlineArray<T, N> (C# 12 feature)
            // Simplified: return the element type as fixed buffer
            // TODO: Proper parsing needed
            isFixedBuffer = true;
            bufferSize = 100; // Default, should parse N
            return "byte"; // Placeholder
        }
        
        // User-defined type (nested struct)
        // Assume it's another struct we'll generate
        return $"{csType}Native";
    }
    
    private void EmitLine(string text = "")
    {
        _sb.AppendLine(text);
    }
}
```

---

### Task 2: Handle Variable-Size Fields (String/Array)

**Problem:** Unbounded strings and arrays need **TWO** fields: pointer + length.

**Solution:** Detect these in schema and emit pair of fields:

```csharp
// For: public string Name;
// Emit:
public IntPtr Name_Ptr;
public int Name_Length;
```

**Update `EmitField` to:**

```csharp
private void EmitField(FieldDeclarationSyntax field, FieldLayout layout)
{
    var fieldType = field.Declaration.Type.ToString();
    var fieldName = field.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "unknown";
    
    // Check for variable-size types
    if (fieldType == "string")
    {
        // Emit pointer + length pair
        EmitLine($"    /// <summary>{fieldName} (unbounded string)</summary>");
        EmitLine($"    public IntPtr {fieldName}_Ptr;");
        EmitLine($"    public int {fieldName}_Length;");
        EmitLine();
        return;
    }
    
    if (fieldType.EndsWith("[]"))
    {
        // Array: element_type[] -> need ptr + length
        var elementType = fieldType[..^2];
        EmitLine($"    /// <summary>{fieldName} (unbounded sequence)</summary>");
        EmitLine($"    public IntPtr {fieldName}_Ptr;");
        EmitLine($"    public int {fieldName}_Length;");
        EmitLine();
        return;
    }
    
    // Rest of logic for fixed-size fields...
}
```

---

### Task 3: Integrate into CodeGenerator

**File:** `tools/CycloneDDS.CodeGen/CodeGenerator.cs` (MODIFY)

Add native type generation after IDL generation:

```csharp
// After IDL generation loop (around line 190)

// Generate Native Types
var nativeEmitter = new NativeTypeEmitter();

foreach (var file in csFiles)
{
    try
    {
        var code = File.ReadAllText(file);
        var tree = CSharpSyntaxTree.ParseText(code, path: file);
        var root = tree.GetRoot();
        var sourceDir = Path.GetDirectoryName(file)!;
        var generatedDir = Path.Combine(sourceDir, "Generated");
        Directory.CreateDirectory(generatedDir);

        // Get namespace
        var namespaceName = GetNamespaceFromRoot(root);

        // Topics
        var topicTypes = root.DescendantNodes()
            .OfType<TypeDeclarationSyntax>()
            .Where(HasDdsTopicAttribute)
            .ToList();

        foreach (var type in topicTypes)
        {
            var nativeCode = nativeEmitter.GenerateNativeStruct(type, namespaceName);
            var nativeFile = Path.Combine(generatedDir, $"{type.Identifier.Text}Native.g.cs");
            File.WriteAllText(nativeFile, nativeCode);
            Console.WriteLine($"[CodeGen]   Generated Native Type: {nativeFile}");
        }
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"[CodeGen] ERROR: Failed to generate native types for {file}: {ex.Message}");
    }
}
```

---

## üß™ Testing Requirements

### Test Project: `tests/CycloneDDS.CodeGen.Tests/NativeTypeEmitterTests.cs` (NEW)

**Minimum 10 tests required:**

1. ‚úÖ `SimplePrimitives_GeneratesCorrectNativeStruct`
2. ‚úÖ `FixedString_GeneratesFixedBuffer`
3. ‚úÖ `Guid_GeneratesFixedByteArray16`
4. ‚úÖ `DateTime_GeneratesInt64Field`
5. ‚úÖ `UnboundedString_GeneratesPtrAndLength`
6. ‚úÖ `UnboundedArray_GeneratesPtrAndLength`
7. ‚úÖ `MixedFields_CorrectLayout`
8. ‚úÖ `NestedStruct_ReferencesNativeType`
9. ‚úÖ `StructLayoutAttribute_Present`
10. ‚úÖ `UnsafeKeyword_Present`

### Example Test:

```csharp
using Xunit;
using CycloneDDS.CodeGen.Emitters;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;

namespace CycloneDDS.CodeGen.Tests;

public class Native TypeEmitterTests
{
    private TypeDeclarationSyntax ParseType(string code)
    {
        var tree = CSharpSyntaxTree.ParseText(code);
        return tree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>().First();
    }
    
    [Fact]
    public void SimplePrimitives_GeneratesCorrectNativeStruct()
    {
        var csCode = @"
[DdsTopic(""SimpleTopic"")]
public partial class SimpleType
{
    public int Id;
    public float Value;
}";
        
        var type = ParseType(csCode);
        var emitter = new NativeTypeEmitter();
        var nativeCode = emitter.GenerateNativeStruct(type, "TestNamespace");
        
        Assert.Contains("struct SimpleTypeNative", nativeCode);
        Assert.Contains("[StructLayout(LayoutKind.Sequential, Pack = 1)]", nativeCode);
        Assert.Contains("public int Id;", nativeCode);
        Assert.Contains("public float Value;", nativeCode);
        Assert.Contains("unsafe", nativeCode);
    }
    
    [Fact]
    public void FixedString_GeneratesFixedBuffer()
    {
        var csCode = @"
[DdsTopic(""StringTopic"")]
public partial class StringType
{
    public FixedString32 Name;
}";
        
        var type = ParseType(csCode);
        var emitter = new NativeTypeEmitter();
        var nativeCode = emitter.GenerateNativeStruct(type, "TestNamespace");
        
        Assert.Contains("public fixed byte Name[32];", nativeCode);
    }
    
    [Fact]
    public void UnboundedString_GeneratesPtrAndLength()
    {
        var csCode = @"
[DdsTopic(""UnboundedTopic"")]
public partial class UnboundedType
{
    public string Description;
}";
        
        var type = ParseType(csCode);
        var emitter = new NativeTypeEmitter();
        var nativeCode = emitter.GenerateNativeStruct(type, "TestNamespace");
        
        Assert.Contains("IntPtr Description_Ptr;", nativeCode);
        Assert.Contains("int Description_Length;", nativeCode);
    }
    
    // ... implement remaining 7 tests ...
}
```

---

## üìä Report Requirements

### Required Sections

1. **Executive Summary**
   - Native struct generation implemented
   - Fixed vs variable-size handling
   - Integration into code generator

2. **Implementation Details**
   - How layout calculator is used
   - Fixed buffer vs pointer fields strategy
   - Handling of special types (Guid, DateTime)

3. **Test Results**
   - All 10+ tests passing
   - Example generated native code

4. **Developer Insights**

   **Q1:** How did you handle the layout calculator integration? Did you encounter any mismatches?

   **Q2:** What's the strategy for unbounded strings/arrays? Why pointer + length?

   **Q3:** What edge cases exist for nested structs that aren't handled yet?

   **Q4:** How would you validate that generated native types have correct sizeof/alignment?

5. **Code Quality Checklist**
   - [ ] NativeTypeEmitter implemented
   - [ ] StructLayout attribute emitted
   - [ ] Pack = 1 specified
   - [ ] unsafe keyword present
   - [ ] Fixed buffers for FixedString
   - [ ] Ptr + Length for unbounded types
   - [ ] Integration into CodeGenerator
   - [ ] 10+ tests passing
   - [ ] All previous tests still passing (46 tests)

---

## üéØ Success Criteria

This batch is DONE when:

1. ‚úÖ NativeTypeEmitter generates blittable structs
2. ‚úÖ [StructLayout(LayoutKind.Sequential, Pack = 1)] emitted
3. ‚úÖ Fixed buffers for bounded data (FixedString, Guid)
4. ‚úÖ IntPtr + int length for unbounded data (string, arrays)
5. ‚úÖ Layout calculator used for field offsets/comments
6. ‚úÖ Integrated into CodeGenerator
7. ‚úÖ Minimum 10 tests passing
8. ‚úÖ All 46 previous tests still passing
9. ‚úÖ Report submitted

---

## ‚ö†Ô∏è Common Pitfalls to Avoid

1. **Pack = 1 is REQUIRED** - Without it, C# compiler may add its own padding
2. **unsafe keyword** - Fixed buffers require unsafe context
3. **Fixed buffer element type** - Must be blittable (byte, int, etc.), NOT string
4. **Unbounded vs Bounded** - string ‚Üí ptr+length, FixedString32 ‚Üí fixed buffer
5. **Layout calculator coordinates** - Use StructLayoutCalculator from BATCH-05
6. **Nested types** - Reference `{Type}Native`, assume it's generated separately
7. **Don't emit unions yet** - Defer to BATCH-07 (explicit layout complexity)

---

## üìö Reference Materials

- **Task Definition:** `docs/FCDC-TASK-MASTER.md` (FCDC-009)
- **Design:** `docs/FCDC-DETAILED-DESIGN.md` (¬ß8 Type System, ¬ß5.1 Phase 4)
- **Layout Calculator:** `tools/CycloneDDS.CodeGen/Layout/StructLayoutCalculator.cs`
- **StructLayout Docs:** https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.structlayoutattribute

---

**Focus: Generate CORRECT blittable native structs that match C memory layout. This enables zero-copy interop with Cyclone DDS.**

**Note:** Unions deferred to BATCH-07 due to explicit layout complexity (discriminator, payload offset).
