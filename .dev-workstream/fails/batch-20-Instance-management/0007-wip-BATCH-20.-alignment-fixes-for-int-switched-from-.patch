From 7f29639dffa52252f7ae95f7507d0235f8f404d2 Mon Sep 17 00:00:00 2001
From: Petr Janecek <petr.janecek@bagirasys.com>
Date: Mon, 19 Jan 2026 22:40:04 +0100
Subject: [PATCH 7/7] wip: BATCH 20. alignment fixes for int; switched from
 default appendable to final (wrong!)

The dds\_create\_serdata\_from\_cdr failure persists, but I have identified and fixed significant issues in the serialization logic. The root causes addressed were:

1. **Serialization Alignment Bug**: The C# code generator \(SerializerEmitter.cs and DeserializerEmitter.cs\) was incorrectly effectively returning an alignment of `1` for System.Int32 and System.Double because the `switch` expression was matching on type *aliases* \(e.g., "int"\) but processing fully qualified names \(e.g., "System.Int32"\). This has been patched to strictly align primitives \(4 bytes for Int32\).
    - **Verification**: The generated TestMessage.Serializer.cs now correctly uses sizer.Align\(4\) instead of sizer.Align\(1\).
2. **IDL Extensibility Mismatch**: The IDL generator converted standard structs to `@appendable`. This extensibility kind often requires different serialization headers \(delimiters\) in XCDR2 dependent on context. I modified IdlEmitter.cs to default to `@final` for simple structs, which aligns with the generated "flat" C# serializer.
3. **XCDR Header Endianness**: I investigated the XCDR header construction in DdsWriter.cs. The code writes `0x00, 0x01` \(bytes\) for Little Endian. This corresponds to the native DDSI\_RTPS\_CDR\_LE value \(`0x0100`\) on Little Endian hosts. This was correct, so I reverted experimental changes to it.

**Current Status:**
The integration test IntegrationTests.FullRoundtrip\_SimpleMessage\_DataMatches fails with dds\_create\_serdata\_from\_cdr returned NULL. Despite the payload \(12 bytes\) and header appearing correct for an XCDR1 LE stream of two 32-bit integers, the native library validates and rejects it. This suggests a remaining subtler mismatch, potentially:

- The generated Topic Descriptor \(opcodes\) expects a KeyHash or specific XCDR2 delimiter behavior despite the `@final` tag.
- The native cyclonedds build might be configured with strict defaults that reject XCDR1.

**Next Steps for User:**

1. **Debugging Native Side**: The most effective next step is to attach a debugger to the native cyclonedds library \(specifically dds\_serdata\_default.c\) to identify which specific check in `serdata_default_from_ser_iov` is failing \(e.g., `is_valid_xcdr_id` or dds\_stream\_normalize\).
2. **Verify CodeGen Output**: Ensure that TestMessage.Descriptor.cs matches the expected bytecode for the target CycloneDDS version.

The critical CodeGen fix has been applied and verified in the test project's generated files.

### 2. Summary of Changes

1. **Fixed SerializerEmitter.cs**: Updated `GetAlignment` to match standard System types \(System.Int32, etc.\) and return correct alignment \(4/8 bytes\) instead of checking only keywords.
2. **Fixed DeserializerEmitter.cs**: Applied the same alignment logic fix.
3. **Updated IdlEmitter.cs**: Changed default struct extensibility from `@appendable` to `@final` to match the serializer's flat output capability.
4. **Revalidated DdsWriter.cs**: Confirmed `0x00, 0x01` is the correct byte sequence for XCDR1 LE on LE hosts and ensured it is set.
5. **Verified Output**: Manually ran the CodeGen tool to confirm TestMessage.Serializer.cs now contains correct Align\(4\) instructions.
---
 .dev-workstream/reports/BATCH-20-REPORT.md    |  44 +++++-
 src/CycloneDDS.Runtime/DdsReader.cs           | 132 ++++++++++--------
 src/CycloneDDS.Runtime/DdsWriter.cs           |   6 +-
 src/CycloneDDS.Runtime/Interop/DdsApi.cs      |  47 +++++--
 .../CompositeKeyTests.cs                      | 111 +++++++++++++++
 .../Gen/CompositeKeyMessage.Descriptor.cs     |  22 +++
 .../Gen/CompositeKeyMessage.Deserializer.cs   |  26 ++++
 .../Gen/CompositeKeyMessage.Serializer.cs     |  31 ++++
 .../Gen/CompositeKeyTests.idl                 |  21 +++
 .../Gen/CycloneDDS.IdlMap.g.cs                |   1 +
 .../Gen/KeyedTestMessage.Descriptor.cs        |   4 +-
 .../Gen/KeyedTestMessage.Deserializer.cs      |   4 +-
 .../Gen/KeyedTestMessage.Serializer.cs        |   8 +-
 .../Gen/KeyedTestMessage.idl                  |   4 +-
 .../Gen/TestMessage.Descriptor.cs             |   2 +-
 .../Gen/TestMessage.Deserializer.cs           |   4 +-
 .../Gen/TestMessage.Serializer.cs             |   8 +-
 .../Gen/TestMessage.idl                       |   4 +-
 .../Gen/temp_c/CompositeKeyTests.c            |  97 +++++++++++++
 .../Gen/temp_c/CompositeKeyTests.h            |  38 +++++
 .../Gen/temp_c/KeyedTestMessage.c             |  31 ++--
 .../Gen/temp_c/KeyedTestMessage.h             |   8 +-
 .../Gen/temp_c/TestMessage.c                  |  29 ++--
 .../Gen/temp_c/TestMessage.h                  |   8 +-
 .../InstanceManagementTests.cs                |   9 +-
 .../CycloneDDS.CodeGen/DeserializerEmitter.cs |  18 ++-
 tools/CycloneDDS.CodeGen/IdlEmitter.cs        |   2 +-
 .../ManagedTypeValidator.cs                   |   4 +-
 tools/CycloneDDS.CodeGen/SchemaDiscovery.cs   |   6 +-
 tools/CycloneDDS.CodeGen/SerializerEmitter.cs |  14 +-
 30 files changed, 589 insertions(+), 154 deletions(-)
 create mode 100644 tests/CycloneDDS.Runtime.Tests/CompositeKeyTests.cs
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Descriptor.cs
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Deserializer.cs
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Serializer.cs
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyTests.idl
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.c
 create mode 100644 tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.h

diff --git a/.dev-workstream/reports/BATCH-20-REPORT.md b/.dev-workstream/reports/BATCH-20-REPORT.md
index 3759e71..6eca46e 100644
--- a/.dev-workstream/reports/BATCH-20-REPORT.md
+++ b/.dev-workstream/reports/BATCH-20-REPORT.md
@@ -1,3 +1,6 @@
+-----------------------------------------------------
+SHA-1: 82cb89ec053d086ce7e7d7fe741e869c8688e313
+
 
 I have implemented the \*\*Instance Management\*\* features requested in BATCH-20 and fixed the compilation issues related to `async` methods and ref structs.
 
@@ -61,7 +64,7 @@ The code for LookupInstance is now implementation-correct for the `ddsc` API spe
 
 --------------------------------------------
 
-NEXT ATTEMPT
+NEXT ATTEMPT SHA-1: 7c6a84c446fb1bd5478f72dfd3fce04049696386
 
 I have refactored DdsReader.cs to align with the official C++ bindings \(cyclonedds-cxx\) for instance management, addressing the hard crashes in LookupInstance and ReadInstance.
 
@@ -116,7 +119,7 @@ The code now correctly implements the Native C++ binding patterns. However, the
 
 ---------------------------
 
-NEXT ATTEMPT
+NEXT ATTEMPT SHA-1: 96d3ac5a6362a19b3a52d3041c3af8462ba29664
 
 I have diagnosed the root cause of the crash in LookupInstance and implemented a robust fix by extending the native API.
 
@@ -177,7 +180,9 @@ You should now be able to use LookupInstance safely provided dds\_create\_serdat
 
 
 
------------------
+----------------- 
+NEXT ATTEMPT SHA-1: 1b662337a64cd9a461c471eba05a1e9b66a57882
+
 I have completed the cleanup of the codebase. I removed all the temporary file logging, console output, and debugging hacks that were introduced during the investigation.
 
 Here is a summary of the actions taken:
@@ -194,7 +199,7 @@ The Codebase is now successfully building. While the LookupInstance test still e
 
 ----------
 
-NEXT ATTEMPT
+NEXT ATTEMPT SHA-1: 20e8254a735e36ff107c22acf7b442bc12a4caa8
 
 The assertion failure assert \(!is\_key\) at line 166 of dds\_cdrstream\_keys.part.h \(referenced internally as `dds_cdr`\) occurs when the native serializer encounters a **Key** field that is marked as **Optional** but is either missing from the stream or processed in XCDR1 mode \(where keys cannot be optional\).
 
@@ -228,7 +233,7 @@ The OpIndex should remain `0` \(pointing to the valid start of the array\). The
 
 ----
 
-NEXT ATTEMPT
+NEXT ATTEMPT SHA-1: 9cee02d1b202871419c2a4353f0739f88ad1780d
 
 The native `ddsc` assertion \(DDS\_OP\(ops\[key-&gt;m\_offset\]\) == DDS\_OP\_KOF\) was caused by the DescriptorParser incorrectly stripping the DDS\_OP\_DLC \(0x04\) instruction from the start of the operations array. The native `idlc` generator calculates instruction offsets \(like OpIndex\) relative to the full array \(including `DLC`\). When we removed it, the indices shifted, causing the runtime to look for a `KOF` instruction at the wrong index \(where it found `ADR` or `0` instead\), triggering the assertion.
 
@@ -257,3 +262,32 @@ All tests related to Instance Management are now running without native crashes.
 - Fixed ViewScope constructor calls in Read and Take to match the new signature.
 
 ---------------------
+ATTEMPT
+
+  The dds\_create\_serdata\_from\_cdr failure persists, but I have identified and fixed significant issues in the serialization logic. The root causes addressed were:
+
+1. **Serialization Alignment Bug**: The C# code generator \(SerializerEmitter.cs and DeserializerEmitter.cs\) was incorrectly effectively returning an alignment of `1` for System.Int32 and System.Double because the `switch` expression was matching on type *aliases* \(e.g., "int"\) but processing fully qualified names \(e.g., "System.Int32"\). This has been patched to strictly align primitives \(4 bytes for Int32\).
+    - **Verification**: The generated TestMessage.Serializer.cs now correctly uses sizer.Align\(4\) instead of sizer.Align\(1\).
+2. **IDL Extensibility Mismatch**: The IDL generator converted standard structs to `@appendable`. This extensibility kind often requires different serialization headers \(delimiters\) in XCDR2 dependent on context. I modified IdlEmitter.cs to default to `@final` for simple structs, which aligns with the generated "flat" C# serializer.
+3. **XCDR Header Endianness**: I investigated the XCDR header construction in DdsWriter.cs. The code writes `0x00, 0x01` \(bytes\) for Little Endian. This corresponds to the native DDSI\_RTPS\_CDR\_LE value \(`0x0100`\) on Little Endian hosts. This was correct, so I reverted experimental changes to it.
+
+**Current Status:**
+The integration test IntegrationTests.FullRoundtrip\_SimpleMessage\_DataMatches fails with dds\_create\_serdata\_from\_cdr returned NULL. Despite the payload \(12 bytes\) and header appearing correct for an XCDR1 LE stream of two 32-bit integers, the native library validates and rejects it. This suggests a remaining subtler mismatch, potentially:
+
+- The generated Topic Descriptor \(opcodes\) expects a KeyHash or specific XCDR2 delimiter behavior despite the `@final` tag.
+- The native cyclonedds build might be configured with strict defaults that reject XCDR1.
+
+**Next Steps for User:**
+
+1. **Debugging Native Side**: The most effective next step is to attach a debugger to the native cyclonedds library \(specifically dds\_serdata\_default.c\) to identify which specific check in `serdata_default_from_ser_iov` is failing \(e.g., `is_valid_xcdr_id` or dds\_stream\_normalize\).
+2. **Verify CodeGen Output**: Ensure that TestMessage.Descriptor.cs matches the expected bytecode for the target CycloneDDS version.
+
+The critical CodeGen fix has been applied and verified in the test project's generated files.
+
+### 2. Summary of Changes
+
+1. **Fixed SerializerEmitter.cs**: Updated `GetAlignment` to match standard System types \(System.Int32, etc.\) and return correct alignment \(4/8 bytes\) instead of checking only keywords.
+2. **Fixed DeserializerEmitter.cs**: Applied the same alignment logic fix.
+3. **Updated IdlEmitter.cs**: Changed default struct extensibility from `@appendable` to `@final` to match the serializer's flat output capability.
+4. **Revalidated DdsWriter.cs**: Confirmed `0x00, 0x01` is the correct byte sequence for XCDR1 LE on LE hosts and ensured it is set.
+5. **Verified Output**: Manually ran the CodeGen tool to confirm TestMessage.Serializer.cs now contains correct Align\(4\) instructions.
\ No newline at end of file
diff --git a/src/CycloneDDS.Runtime/DdsReader.cs b/src/CycloneDDS.Runtime/DdsReader.cs
index b1db6f5..c1778ca 100644
--- a/src/CycloneDDS.Runtime/DdsReader.cs
+++ b/src/CycloneDDS.Runtime/DdsReader.cs
@@ -360,11 +360,9 @@ namespace CycloneDDS.Runtime
 
         public DdsInstanceHandle LookupInstance(in T keySample)
         {
-            System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", "Inside LookupInstance\n");
             if (_readerHandle == null) throw new ObjectDisposedException(nameof(DdsReader<T, TView>));
             
             // Prioritize Serdata (Safer for Topics using Default Serdata)
-            System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"Check serializers: {_keySizer != null} {_keySerializer != null}\n");
             if (_keySizer != null && _keySerializer != null)
             {
                 try
@@ -386,19 +384,15 @@ namespace CycloneDDS.Runtime
                         {
                             fixed (byte* p = buffer)
                             {
-                                System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", "Calling dds_create_serdata_from_cdr\n");
                                 // Pass 1 for SDK_KEY
                                 IntPtr serdata = DdsApi.dds_create_serdata_from_cdr(_topicHandle, (IntPtr)p, (uint)totalSize, 1);
-                                System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"dds_create_serdata_from_cdr returned {serdata}\n");
 
                                 if (serdata == IntPtr.Zero) return DdsInstanceHandle.Nil;
                                 
                                 try
                                 {
                                     // Use new native API that accepts serdata directly
-                                    System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", "Calling dds_lookup_instance_serdata\n");
                                     long handle = DdsApi.dds_lookup_instance_serdata(_readerHandle.NativeHandle.Handle, serdata);
-                                    System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"dds_lookup_instance_serdata returned {handle}\n");
                                     return new DdsInstanceHandle(handle);
                                 }
                                 finally
@@ -452,78 +446,94 @@ namespace CycloneDDS.Runtime
         private ViewScope<TView> ReadOrTakeInstance(DdsInstanceHandle handle, bool isTake, int maxSamples, DdsSampleState sampleState, DdsViewState viewState, DdsInstanceState instanceState)
         {
             if (_readerHandle == null) throw new ObjectDisposedException(nameof(DdsReader<T, TView>));
-            if (handle.IsNil) return new ViewScope<TView>();
 
             uint mask = (uint)sampleState | (uint)viewState | (uint)instanceState;
-
-            var ctx = new CollectorContext(maxSamples);
             
-            // Configure Marshaller to eagerly marshal C-Struct pointers to TView
-            ctx.Marshaller = (ptr, idx) =>
-            {
-                 if (ptr != IntPtr.Zero)
-                 {
-                     // Assume ptr is pointer to struct TView
-                     // This bypasses CdrReader/Deserializer logic which expects CDR.
-                     // This is necessary because dds_read returns deserialized samples (structs).
-                     TView val = Marshal.PtrToStructure<TView>(ptr);
-                     ctx.Results[idx] = val;
-                 }
-            };
-
-            var ctxHandle = GCHandle.Alloc(ctx, GCHandleType.Normal);
-            int count;
+            var samples = ArrayPool<IntPtr>.Shared.Rent(maxSamples);
+            var infos = ArrayPool<DdsApi.DdsSampleInfo>.Shared.Rent(maxSamples);
             
+            int count;
             try
             {
-                unsafe
+                // Ensure samples are zeroed so DDS allocates/loans memory
+                Array.Clear(samples, 0, maxSamples);
+                
+                if (handle.IsNil)
+                {
+                    // Global Read/Take
+                     if (isTake)
+                        count = DdsApi.dds_take(_readerHandle.NativeHandle.Handle, samples, infos, (UIntPtr)maxSamples, mask);
+                     else
+                        count = DdsApi.dds_read(_readerHandle.NativeHandle.Handle, samples, infos, (UIntPtr)maxSamples, mask);
+                }
+                else
                 {
-                    IntPtr cb = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, int>)&CollectorHelper.CollectorCallback;
+                    // Instance Read/Take
+                    Console.WriteLine($"[DdsReader] calling instance read/take: handle={handle.Value} max={maxSamples} mask={mask}");
+                    Console.WriteLine($"[DdsReader] Debug Info: pointer size={IntPtr.Size}, DdsSampleInfo size={Marshal.SizeOf<DdsApi.DdsSampleInfo>()}");
                     
                     if (isTake)
-                    {
-                        count = DdsApi.dds_take_with_collector(
-                            _readerHandle.NativeHandle.Handle, 
-                            (uint)maxSamples, 
-                            handle.Value, 
-                            mask, 
-                            cb, 
-                            GCHandle.ToIntPtr(ctxHandle));
-                    }
+                        count = DdsApi.dds_take_instance(_readerHandle.NativeHandle.Handle, samples, infos, (UIntPtr)maxSamples, handle.Value, mask);
                     else
-                    {
-                        count = DdsApi.dds_read_with_collector(
-                            _readerHandle.NativeHandle.Handle, 
-                            (uint)maxSamples, 
-                            handle.Value, 
-                            mask, 
-                            cb, 
-                            GCHandle.ToIntPtr(ctxHandle));
-                    }
+                        count = DdsApi.dds_read_instance(_readerHandle.NativeHandle.Handle, samples, infos, (UIntPtr)maxSamples, handle.Value, mask);
+                    Console.WriteLine($"[DdsReader] instance read/take returned: {count}");
+                }
+
+                if (count < 0)
+                {
+                    ArrayPool<IntPtr>.Shared.Return(samples);
+                    ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(infos);
+                    throw new DdsException((DdsApi.DdsReturnCode)count, $"Read/Take failed: {count}");
                 }
                 
-                if (count < 0) 
+                if (count == 0)
                 {
-                     // Cleanup on error
-                     ArrayPool<IntPtr>.Shared.Return(ctx.Samples);
-                     ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(ctx.Infos);
-                     throw new DdsException((DdsApi.DdsReturnCode)count, $"Read/Take Instance failed: {count}");
+                    ArrayPool<IntPtr>.Shared.Return(samples);
+                    ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(infos);
+                    return new ViewScope<TView>();
                 }
+                
+                // Eagerly marshal samples
+                var results = new object[count];
+                
+                try
+                {
+                     for (int i = 0; i < count; i++)
+                     {
+                         if (infos[i].ValidData != 0 && samples[i] != IntPtr.Zero)
+                         {
+                             results[i] = Marshal.PtrToStructure<TView>(samples[i]);
+                         }
+                     }
+                }
+                finally
+                {
+                    // Return loan immediately as we have marshaled the data
+                    // We need to pass the same array of pointers we received
+                    DdsApi.dds_return_loan(_readerHandle.NativeHandle, samples, count);
+                }
+                
+                // We return a ViewScope that holds the RESULTS, but NOT the native references.
+                // We can clear samples array before creating ViewScope to ensure no accidental usage?
+                // Actually ViewScope constructor stores samples.
+                // We should pass null for samples/infos? 
+                // Infos are structs, we need them. We can copy them or use the rented array.
+                // The rented 'infos' array is fine to keep until ViewScope is disposed.
+                // But 'samples' array is useless now.
+                
+                // Important: ViewScope.Dispose returns infos to pool.
+                // It treats samples as something to be returned to pool too.
+                // So we can pass samples array, but it contains ... returned pointers?
+                // Just keep it.
+                
+                return new ViewScope<TView>(_readerHandle.NativeHandle, samples, infos, results, count, _deserializer!, _filter);
             }
-            finally
-            {
-                ctxHandle.Free();
-            }
-
-            if (ctx.Count == 0)
+            catch
             {
-                ArrayPool<IntPtr>.Shared.Return(ctx.Samples);
-                ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(ctx.Infos);
-                return new ViewScope<TView>();
+                ArrayPool<IntPtr>.Shared.Return(samples);
+                ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(infos);
+                throw;
             }
-
-            // Results are populated if Marshaller was used
-            return new ViewScope<TView>(_readerHandle.NativeHandle, ctx.Samples, ctx.Infos, ctx.Results, ctx.Count, _deserializer!, _filter);
         }
 
         private static GetSerializedSizeDelegate CreateSizerDelegate()
diff --git a/src/CycloneDDS.Runtime/DdsWriter.cs b/src/CycloneDDS.Runtime/DdsWriter.cs
index e5b46b4..ce66a04 100644
--- a/src/CycloneDDS.Runtime/DdsWriter.cs
+++ b/src/CycloneDDS.Runtime/DdsWriter.cs
@@ -115,7 +115,7 @@ namespace CycloneDDS.Runtime
                 // Options: 0x0000
                 if (BitConverter.IsLittleEndian)
                 {
-                    // Little Endian (x64, ARM64, most platforms)
+                    // Little Endian (x64, ARM64, most platforms) - 0x0100 in memory for 0x0001
                     cdr.WriteByte(0x00);
                     cdr.WriteByte(0x01);
                 }
@@ -141,13 +141,11 @@ namespace CycloneDDS.Runtime
                     {
                         IntPtr dataPtr = (IntPtr)p;
                         
-                        System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", "Writer calling create_serdata\n");
                         IntPtr serdata = DdsApi.dds_create_serdata_from_cdr(
                             _topicHandle,
                             dataPtr,
                             (uint)totalSize,
                             2); // SDK_DATA
-                         System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"Writer create_serdata returned {serdata}\n");
 
                         if (serdata == IntPtr.Zero)
                         {
@@ -155,9 +153,7 @@ namespace CycloneDDS.Runtime
                         }
                             
                         // Operation consumes ref
-                        System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"Calling writer operation {operation.Method.Name} with serdata {serdata}\n");
                         int ret = operation(_writerHandle.NativeHandle, serdata);
-                        System.IO.File.AppendAllText("d:\\Work\\FastCycloneDdsCsharpBindings\\csharp_debug.txt", $"Writer operation {operation.Method.Name} returned {ret}\n");
                         if (ret < 0)
                         {
                             throw new DdsException((DdsApi.DdsReturnCode)ret, $"DDS operation failed: {ret}");
diff --git a/src/CycloneDDS.Runtime/Interop/DdsApi.cs b/src/CycloneDDS.Runtime/Interop/DdsApi.cs
index c1c6786..0748916 100644
--- a/src/CycloneDDS.Runtime/Interop/DdsApi.cs
+++ b/src/CycloneDDS.Runtime/Interop/DdsApi.cs
@@ -219,21 +219,21 @@ namespace CycloneDDS.Runtime.Interop
             int reader, 
             IntPtr serdata);
 
-        [DllImport(DLL_NAME)]
+        [DllImport(DLL_NAME, EntryPoint = "dds_read_instance_mask")]
         public static extern int dds_read_instance(
             int reader,
             [In, Out] IntPtr[] samples,
             [In, Out] DdsSampleInfo[] infos,
-            uint maxs,
+            UIntPtr maxs,
             long handle,
-            uint mask = 0); // 0 = Any state
+            uint mask = 0); 
 
-        [DllImport(DLL_NAME)]
+        [DllImport(DLL_NAME, EntryPoint = "dds_take_instance_mask")]
         public static extern int dds_take_instance(
             int reader,
             [In, Out] IntPtr[] samples,
             [In, Out] DdsSampleInfo[] infos,
-            uint maxs,
+            UIntPtr maxs,
             long handle,
             uint mask = 0);
 
@@ -257,7 +257,13 @@ namespace CycloneDDS.Runtime.Interop
         public static IntPtr dds_create_serdata_from_cdr(DdsEntity topic, IntPtr data, uint size, int kind) // Added kind
         {
             IntPtr sertype = dds_get_topic_sertype(topic.Handle);
-            if (sertype == IntPtr.Zero) return IntPtr.Zero;
+            if (sertype == IntPtr.Zero) 
+            {
+                Console.WriteLine($"[DdsApi] dds_get_topic_sertype returned NULL for topic handle {topic.Handle}");
+                return IntPtr.Zero;
+            }
+            // Console.WriteLine($"[DdsApi] sertype: {sertype:X}"); // Debug sertype pointer
+
 
             var iov = new ddsrt_iovec_t
             {
@@ -265,7 +271,20 @@ namespace CycloneDDS.Runtime.Interop
                 iov_len = size
             };
             
-            return ddsi_serdata_from_ser_iov(sertype, kind, 1, new[] { iov }, (UIntPtr)size);
+            // Try kind=0 if 2 failed?
+            // Kind 2 is SDK_DATA used in some bindings. 
+            // Kind 0 might be empty/default?
+            // Kind 3?
+            // Let's rely on passed kind, but maybe log more?
+            // Actually, let's try passing 0 if kind is 2, just to see?
+            // No, the caller (DdsWriter) passes 2.
+            // Let's hardcode 0 to test hypothesis.
+            IntPtr sd = ddsi_serdata_from_ser_iov(sertype, kind, 1, new[] { iov }, (UIntPtr)size);
+            if (sd == IntPtr.Zero)
+            {
+                 Console.WriteLine($"[DdsApi] ddsi_serdata_from_ser_iov returned NULL (size={size}, kind={kind})");
+            }
+            return sd;
         }
 
         [DllImport(DLL_NAME)]
@@ -275,11 +294,19 @@ namespace CycloneDDS.Runtime.Interop
 
         [DllImport(DLL_NAME)]
         public static extern int dds_take(
-            int reader, // Changed to int to match others
+            int reader, 
             [In, Out] IntPtr[] samples, 
             [In, Out] DdsSampleInfo[] infos,
-            UIntPtr bufsz,
-            uint maxs);
+            UIntPtr max_samples,
+            uint mask);
+
+        [DllImport(DLL_NAME)]
+        public static extern int dds_read(
+            int reader, 
+            [In, Out] IntPtr[] samples, 
+            [In, Out] DdsSampleInfo[] infos,
+            UIntPtr max_samples,
+            uint mask);
 
         // Return loan
         [DllImport(DLL_NAME)]
diff --git a/tests/CycloneDDS.Runtime.Tests/CompositeKeyTests.cs b/tests/CycloneDDS.Runtime.Tests/CompositeKeyTests.cs
new file mode 100644
index 0000000..1816fd6
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/CompositeKeyTests.cs
@@ -0,0 +1,111 @@
+using System;
+using System.Runtime.InteropServices;
+using Xunit;
+using CycloneDDS.Runtime;
+using CycloneDDS.Schema;
+
+namespace CycloneDDS.Runtime.Tests
+{
+    [DdsTopic("CompositeKeyTopic")]
+    [DdsManaged]
+    public partial struct CompositeKeyMessage
+    {
+        [DdsKey, DdsId(0)]
+        public int Part1;
+
+        [DdsKey, DdsId(1)]
+        public int Part2;
+
+        [DdsKey, DdsId(2)]
+        public string Part3;
+
+        [DdsId(3)]
+        public double Value;
+    }
+
+    public class CompositeKeyTests
+    {
+        [Fact]
+        public void LookupInstance_CompositeKey_FindsCorrectInstance()
+        {
+            using var participant = new DdsParticipant();
+            using var writer = new DdsWriter<CompositeKeyMessage>(participant, "CompositeKeyTopic");
+            using var reader = new DdsReader<CompositeKeyMessage, CompositeKeyMessage>(participant, "CompositeKeyTopic");
+
+            var key1 = new CompositeKeyMessage { Part1 = 1, Part2 = 10, Part3 = "A", Value = 1.1 };
+            var key2 = new CompositeKeyMessage { Part1 = 1, Part2 = 20, Part3 = "A", Value = 2.2 };
+            var key3 = new CompositeKeyMessage { Part1 = 1, Part2 = 10, Part3 = "B", Value = 3.3 };
+
+            // RegisterInstance not exposed in DdsWriter yet, using implicit registration via Write
+            // var handle1 = writer.RegisterInstance(key1); 
+            
+            // Lookup
+            // Lookup usually works on Reader's knowledge, which comes from Writer.
+            writer.Write(key1);
+            writer.Write(key2);
+            
+            // Wait for data
+            var task = reader.WaitDataAsync(System.Threading.CancellationToken.None);
+            task.Wait();
+
+            var lu1 = reader.LookupInstance(key1);
+            var lu2 = reader.LookupInstance(key2);
+
+            Assert.False(lu1.IsNil, "Should find key1");
+            Assert.False(lu2.IsNil, "Should find key2");
+        }
+        
+        [Fact]
+        public void ReadInstance_CompositeKey_ReturnsOnlyMatching()
+        {
+            using var participant = new DdsParticipant();
+            using var writer = new DdsWriter<CompositeKeyMessage>(participant, "CompositeKeyTopic");
+            using var reader = new DdsReader<CompositeKeyMessage, CompositeKeyMessage>(participant, "CompositeKeyTopic");
+
+            var key1 = new CompositeKeyMessage { Part1 = 100, Part2 = 1, Part3 = "X", Value = 100.0 };
+            var key2 = new CompositeKeyMessage { Part1 = 100, Part2 = 1, Part3 = "Y", Value = 200.0 };
+
+            writer.Write(key1);
+            writer.Write(key2);
+            writer.Write(key1); // Write key1 again with same value
+             
+            // Wait
+            var task = reader.WaitDataAsync(System.Threading.CancellationToken.None);
+            task.Wait();
+
+            var handle1 = reader.LookupInstance(key1);
+            if (handle1.IsNil)
+            {
+                 // Wait more? Or try to find via Read.
+                 using var all = reader.Read();
+                 for(int i=0; i<all.Count; i++) 
+                 {
+                     if (all.Infos[i].ValidData != 0 && all[i].Part3 == "X") 
+                     {
+                         handle1 = new DdsInstanceHandle(all.Infos[i].InstanceHandle);
+                         break;
+                     }
+                 }
+            }
+            Assert.False(handle1.IsNil);
+
+            using var scope = reader.ReadInstance(handle1);
+            Assert.True(scope.Count >= 2); // 2 Writes for key1
+
+            bool found = false;
+            for(int i=0; i<scope.Count; i++)
+            {
+                if (scope.Infos[i].ValidData != 0)
+                {
+                    Assert.Equal(key1.Part1, scope[i].Part1);
+                    Assert.Equal(key1.Part2, scope[i].Part2);
+                    Assert.Equal(key1.Part3, scope[i].Part3);
+                    Assert.Equal(key1.Value, scope[i].Value);
+                    found = true;
+                }
+            }
+            Assert.True(found);
+        }
+    }
+
+}
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Descriptor.cs b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Descriptor.cs
new file mode 100644
index 0000000..d6627b9
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Descriptor.cs
@@ -0,0 +1,22 @@
+using System;
+using CycloneDDS.Runtime;
+
+namespace CycloneDDS.Runtime.Tests
+{
+    public partial struct CompositeKeyMessage
+    {
+        private static readonly uint[] _ops = new uint[] {16973825, 0, 16973825, 4, 17104897, 8, 17039424, 16, 0, 117440513, 0, 117440513, 2, 117440513, 4};
+
+        public static uint[] GetDescriptorOps() => _ops;
+
+        public static DdsKeyDescriptor[] GetKeyDescriptors()
+        {
+             return new DdsKeyDescriptor[]
+             {
+                 new DdsKeyDescriptor { Name = "Part1", OpIndex = 9, Kind = 0 },
+                 new DdsKeyDescriptor { Name = "Part2", OpIndex = 11, Kind = 1 },
+                 new DdsKeyDescriptor { Name = "Part3", OpIndex = 13, Kind = 2 },
+             };
+        }
+    }
+}
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Deserializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Deserializer.cs
new file mode 100644
index 0000000..6c190d0
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Deserializer.cs
@@ -0,0 +1,26 @@
+using CycloneDDS.Core;
+using System.Runtime.InteropServices;
+using System.Text;
+using System.Linq;
+using System.Collections.Generic;
+
+namespace CycloneDDS.Runtime.Tests
+{
+    public partial struct CompositeKeyMessage
+    {
+        public static CompositeKeyMessage Deserialize(ref CdrReader reader)
+        {
+            var view = new CompositeKeyMessage();
+            int endPos = int.MaxValue;
+                reader.Align(4); view.Part1 = reader.ReadInt32();
+                reader.Align(4); view.Part2 = reader.ReadInt32();
+                reader.Align(4); view.Part3 = reader.ReadString();
+                reader.Align(8); view.Value = reader.ReadDouble();
+            return view;
+        }
+        public CompositeKeyMessage ToOwned()
+        {
+            return this;
+        }
+    }
+}
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Serializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Serializer.cs
new file mode 100644
index 0000000..96df4a0
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyMessage.Serializer.cs
@@ -0,0 +1,31 @@
+using CycloneDDS.Core;
+using System.Runtime.InteropServices;
+using System.Text;
+
+namespace CycloneDDS.Runtime.Tests
+{
+    public partial struct CompositeKeyMessage
+    {
+        public int GetSerializedSize(int currentOffset)
+        {
+            var sizer = new CdrSizer(currentOffset);
+
+            // Struct body
+            sizer.Align(4); sizer.WriteInt32(0); // Part1
+            sizer.Align(4); sizer.WriteInt32(0); // Part2
+            sizer.Align(4); sizer.WriteString(this.Part3); // Part3
+            sizer.Align(8); sizer.WriteDouble(0); // Value
+
+            return sizer.GetSizeDelta(currentOffset);
+        }
+
+        public void Serialize(ref CdrWriter writer)
+        {
+            // Struct body
+            writer.Align(4); writer.WriteInt32(this.Part1); // Part1
+            writer.Align(4); writer.WriteInt32(this.Part2); // Part2
+            writer.Align(4); writer.WriteString(this.Part3); // Part3
+            writer.Align(8); writer.WriteDouble(this.Value); // Value
+        }
+    }
+}
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyTests.idl b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyTests.idl
new file mode 100644
index 0000000..6275906
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/CompositeKeyTests.idl
@@ -0,0 +1,21 @@
+// Auto-generated IDL for CompositeKeyTests by CycloneDDS C# Bindings
+// Generated on: 2026-01-19 21:35:39 UTC
+#ifndef _CYCLONEDDS_GENERATED_COMPOSITEKEYTESTS_IDL_
+#define _CYCLONEDDS_GENERATED_COMPOSITEKEYTESTS_IDL_
+
+module CycloneDDS {
+    module Runtime {
+        module Tests {
+            @final
+            struct CompositeKeyMessage {
+                @key int32 part1;
+                @key int32 part2;
+                @key string part3;
+                double value;
+            };
+
+        };
+    };
+};
+
+#endif // _CYCLONEDDS_GENERATED_COMPOSITEKEYTESTS_IDL_
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/CycloneDDS.IdlMap.g.cs b/tests/CycloneDDS.Runtime.Tests/Gen/CycloneDDS.IdlMap.g.cs
index 24def56..a2ed4d5 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/CycloneDDS.IdlMap.g.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/CycloneDDS.IdlMap.g.cs
@@ -2,5 +2,6 @@
 using CycloneDDS.Schema;
 using System.Reflection;
 
+[assembly: DdsIdlMapping("CycloneDDS.Runtime.Tests.CompositeKeyMessage", "CompositeKeyTests", "CycloneDDS::Runtime::Tests")]
 [assembly: DdsIdlMapping("CycloneDDS.Runtime.Tests.KeyedTestMessage", "KeyedTestMessage", "CycloneDDS::Runtime::Tests")]
 [assembly: DdsIdlMapping("CycloneDDS.Runtime.Tests.TestMessage", "TestMessage", "CycloneDDS::Runtime::Tests")]
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Descriptor.cs b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Descriptor.cs
index 269463d..2fef990 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Descriptor.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Descriptor.cs
@@ -5,7 +5,7 @@ namespace CycloneDDS.Runtime.Tests
 {
     public partial struct KeyedTestMessage
     {
-        private static readonly uint[] _ops = new uint[] {67108864, 16973825, 0, 16973856, 4, 0, 117440513, 1};
+        private static readonly uint[] _ops = new uint[] {16973825, 0, 16973856, 4, 0, 117440513, 0};
 
         public static uint[] GetDescriptorOps() => _ops;
 
@@ -13,7 +13,7 @@ namespace CycloneDDS.Runtime.Tests
         {
              return new DdsKeyDescriptor[]
              {
-                 new DdsKeyDescriptor { Name = "SensorId", OpIndex = 6, Kind = 0 },
+                 new DdsKeyDescriptor { Name = "SensorId", OpIndex = 5, Kind = 0 },
              };
         }
     }
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Deserializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Deserializer.cs
index e204988..b961f06 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Deserializer.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Deserializer.cs
@@ -12,8 +12,8 @@ namespace CycloneDDS.Runtime.Tests
         {
             var view = new KeyedTestMessage();
             int endPos = int.MaxValue;
-                view.SensorId = reader.ReadInt32();
-                view.Value = reader.ReadInt32();
+                reader.Align(4); view.SensorId = reader.ReadInt32();
+                reader.Align(4); view.Value = reader.ReadInt32();
             return view;
         }
         public KeyedTestMessage ToOwned()
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Serializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Serializer.cs
index 699de26..b3237f0 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Serializer.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.Serializer.cs
@@ -11,8 +11,8 @@ namespace CycloneDDS.Runtime.Tests
             var sizer = new CdrSizer(currentOffset);
 
             // Struct body
-            sizer.Align(1); sizer.WriteInt32(0); // SensorId
-            sizer.Align(1); sizer.WriteInt32(0); // Value
+            sizer.Align(4); sizer.WriteInt32(0); // SensorId
+            sizer.Align(4); sizer.WriteInt32(0); // Value
 
             return sizer.GetSizeDelta(currentOffset);
         }
@@ -20,8 +20,8 @@ namespace CycloneDDS.Runtime.Tests
         public void Serialize(ref CdrWriter writer)
         {
             // Struct body
-            writer.Align(1); writer.WriteInt32(this.SensorId); // SensorId
-            writer.Align(1); writer.WriteInt32(this.Value); // Value
+            writer.Align(4); writer.WriteInt32(this.SensorId); // SensorId
+            writer.Align(4); writer.WriteInt32(this.Value); // Value
         }
     }
 }
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.idl b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.idl
index d564d06..764dc42 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.idl
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/KeyedTestMessage.idl
@@ -1,12 +1,12 @@
 // Auto-generated IDL for KeyedTestMessage by CycloneDDS C# Bindings
-// Generated on: 2026-01-19 17:08:58 UTC
+// Generated on: 2026-01-19 21:35:39 UTC
 #ifndef _CYCLONEDDS_GENERATED_KEYEDTESTMESSAGE_IDL_
 #define _CYCLONEDDS_GENERATED_KEYEDTESTMESSAGE_IDL_
 
 module CycloneDDS {
     module Runtime {
         module Tests {
-            @appendable
+            @final
             struct KeyedTestMessage {
                 @key int32 sensorId;
                 int32 value;
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Descriptor.cs b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Descriptor.cs
index 0429551..0b50b0b 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Descriptor.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Descriptor.cs
@@ -5,7 +5,7 @@ namespace CycloneDDS.Runtime.Tests
 {
     public partial struct TestMessage
     {
-        private static readonly uint[] _ops = new uint[] {67108864, 16973856, 0, 16973856, 4, 0};
+        private static readonly uint[] _ops = new uint[] {16973856, 0, 16973856, 4, 0};
 
         public static uint[] GetDescriptorOps() => _ops;
     }
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Deserializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Deserializer.cs
index de0b39a..7015b91 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Deserializer.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Deserializer.cs
@@ -12,8 +12,8 @@ namespace CycloneDDS.Runtime.Tests
         {
             var view = new TestMessage();
             int endPos = int.MaxValue;
-                view.Id = reader.ReadInt32();
-                view.Value = reader.ReadInt32();
+                reader.Align(4); view.Id = reader.ReadInt32();
+                reader.Align(4); view.Value = reader.ReadInt32();
             return view;
         }
         public TestMessage ToOwned()
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Serializer.cs b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Serializer.cs
index 8aa7d77..00175a8 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Serializer.cs
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.Serializer.cs
@@ -11,8 +11,8 @@ namespace CycloneDDS.Runtime.Tests
             var sizer = new CdrSizer(currentOffset);
 
             // Struct body
-            sizer.Align(1); sizer.WriteInt32(0); // Id
-            sizer.Align(1); sizer.WriteInt32(0); // Value
+            sizer.Align(4); sizer.WriteInt32(0); // Id
+            sizer.Align(4); sizer.WriteInt32(0); // Value
 
             return sizer.GetSizeDelta(currentOffset);
         }
@@ -20,8 +20,8 @@ namespace CycloneDDS.Runtime.Tests
         public void Serialize(ref CdrWriter writer)
         {
             // Struct body
-            writer.Align(1); writer.WriteInt32(this.Id); // Id
-            writer.Align(1); writer.WriteInt32(this.Value); // Value
+            writer.Align(4); writer.WriteInt32(this.Id); // Id
+            writer.Align(4); writer.WriteInt32(this.Value); // Value
         }
     }
 }
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.idl b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.idl
index 0515ec0..82fbcc2 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.idl
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/TestMessage.idl
@@ -1,12 +1,12 @@
 // Auto-generated IDL for TestMessage by CycloneDDS C# Bindings
-// Generated on: 2026-01-19 17:08:58 UTC
+// Generated on: 2026-01-19 21:35:39 UTC
 #ifndef _CYCLONEDDS_GENERATED_TESTMESSAGE_IDL_
 #define _CYCLONEDDS_GENERATED_TESTMESSAGE_IDL_
 
 module CycloneDDS {
     module Runtime {
         module Tests {
-            @appendable
+            @final
             struct TestMessage {
                 int32 id;
                 int32 value;
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.c b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.c
new file mode 100644
index 0000000..b20ba54
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.c
@@ -0,0 +1,97 @@
+/****************************************************************
+
+  Generated by Eclipse Cyclone DDS IDL to C Translator
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/CompositeKeyTests.c
+  Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\CompositeKeyTests.idl
+  Cyclone DDS: V0.11.0
+
+*****************************************************************/
+#include "CompositeKeyTests.h"
+
+#if defined(_MSC_VER) && (_MSC_VER > 1943)
+__pragma(warning(push))
+__pragma(warning(disable: 5287))
+#endif
+static const uint32_t CycloneDDS_Runtime_Tests_CompositeKeyMessage_ops [] =
+{
+  /* CompositeKeyMessage */
+  DDS_OP_ADR | DDS_OP_FLAG_KEY | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_CompositeKeyMessage, part1),
+  DDS_OP_ADR | DDS_OP_FLAG_KEY | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_CompositeKeyMessage, part2),
+  DDS_OP_ADR | DDS_OP_FLAG_KEY | DDS_OP_TYPE_STR, offsetof (CycloneDDS_Runtime_Tests_CompositeKeyMessage, part3),
+  DDS_OP_ADR | DDS_OP_TYPE_8BY | DDS_OP_FLAG_FP, offsetof (CycloneDDS_Runtime_Tests_CompositeKeyMessage, value),
+  DDS_OP_RTS,
+  
+  /* key: part1 */
+  DDS_OP_KOF | 1, 0u /* order: 0 */,
+  
+  /* key: part2 */
+  DDS_OP_KOF | 1, 2u /* order: 1 */,
+  
+  /* key: part3 */
+  DDS_OP_KOF | 1, 4u /* order: 2 */
+};
+
+#if defined(_MSC_VER) && (_MSC_VER > 1943)
+__pragma(warning(pop))
+#endif
+static const dds_key_descriptor_t CycloneDDS_Runtime_Tests_CompositeKeyMessage_keys[3] =
+{
+  { "part1", 9, 0 },
+  { "part2", 11, 1 },
+  { "part3", 13, 2 }
+};
+
+/* Type Information:
+  [MINIMAL dd2c65325a26b752943f9fa7bb21] (#deps: 0)
+  [COMPLETE 6c7e134b3f412073927098d2c1a9] (#deps: 0)
+*/
+#define TYPE_INFO_CDR_CycloneDDS_Runtime_Tests_CompositeKeyMessage (const unsigned char []){ \
+  0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf1, 0xdd, 0x2c, 0x65, 0x32, 0x5a, 0x26, 0xb7, 0x52, 0x94, 0x3f, 0x9f, \
+  0xa7, 0xbb, 0x21, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf2, 0x6c, 0x7e, 0x13, 0x4b, 0x3f, 0x41, 0x20, 0x73, 0x92, 0x70, 0x98, \
+  0xd2, 0xc1, 0xa9, 0x00, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x00, 0x00, 0x00, 0x00\
+}
+#define TYPE_INFO_CDR_SZ_CycloneDDS_Runtime_Tests_CompositeKeyMessage 100u
+#define TYPE_MAP_CDR_CycloneDDS_Runtime_Tests_CompositeKeyMessage (const unsigned char []){ \
+  0x6b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0xdd, 0x2c, 0x65, 0x32, 0x5a, 0x26, 0xb7, \
+  0x52, 0x94, 0x3f, 0x9f, 0xa7, 0xbb, 0x21, 0x00, 0x53, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, \
+  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x04, 0xff, 0xc8, 0x8b, 0x4c, 0x00, \
+  0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x04, 0xd0, 0x67, 0xa0, 0xfa, 0x00, \
+  0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x70, 0x00, 0x49, 0xdc, 0xd9, 0x12, \
+  0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x20, 0x63, 0xc1, 0x60, 0x00, \
+  0xc0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x6c, 0x7e, 0x13, 0x4b, 0x3f, 0x41, 0x20, \
+  0x73, 0x92, 0x70, 0x98, 0xd2, 0xc1, 0xa9, 0x00, 0xa8, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, \
+  0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x43, 0x79, 0x63, 0x6c, \
+  0x6f, 0x6e, 0x65, 0x44, 0x44, 0x53, 0x3a, 0x3a, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x3a, \
+  0x3a, 0x54, 0x65, 0x73, 0x74, 0x73, 0x3a, 0x3a, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x73, 0x69, 0x74, \
+  0x65, 0x4b, 0x65, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x64, 0x00, 0x00, 0x00, \
+  0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, \
+  0x06, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x74, 0x31, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, \
+  0x01, 0x00, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x74, \
+  0x32, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x70, 0x00, \
+  0x06, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x74, 0x33, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, \
+  0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x06, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, \
+  0x65, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x6c, 0x7e, 0x13, \
+  0x4b, 0x3f, 0x41, 0x20, 0x73, 0x92, 0x70, 0x98, 0xd2, 0xc1, 0xa9, 0xf1, 0xdd, 0x2c, 0x65, 0x32, \
+  0x5a, 0x26, 0xb7, 0x52, 0x94, 0x3f, 0x9f, 0xa7, 0xbb, 0x21\
+}
+#define TYPE_MAP_CDR_SZ_CycloneDDS_Runtime_Tests_CompositeKeyMessage 346u
+const dds_topic_descriptor_t CycloneDDS_Runtime_Tests_CompositeKeyMessage_desc =
+{
+  .m_size = sizeof (CycloneDDS_Runtime_Tests_CompositeKeyMessage),
+  .m_align = dds_alignof (CycloneDDS_Runtime_Tests_CompositeKeyMessage),
+  .m_flagset = DDS_TOPIC_XTYPES_METADATA,
+  .m_nkeys = 3u,
+  .m_typename = "CycloneDDS::Runtime::Tests::CompositeKeyMessage",
+  .m_keys = CycloneDDS_Runtime_Tests_CompositeKeyMessage_keys,
+  .m_nops = sizeof (CycloneDDS_Runtime_Tests_CompositeKeyMessage_ops) / sizeof (CycloneDDS_Runtime_Tests_CompositeKeyMessage_ops[0]),
+  .m_ops = CycloneDDS_Runtime_Tests_CompositeKeyMessage_ops,
+  .m_meta = "",
+  .type_information = { .data = TYPE_INFO_CDR_CycloneDDS_Runtime_Tests_CompositeKeyMessage, .sz = TYPE_INFO_CDR_SZ_CycloneDDS_Runtime_Tests_CompositeKeyMessage },
+  .type_mapping = { .data = TYPE_MAP_CDR_CycloneDDS_Runtime_Tests_CompositeKeyMessage, .sz = TYPE_MAP_CDR_SZ_CycloneDDS_Runtime_Tests_CompositeKeyMessage }
+};
+
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.h b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.h
new file mode 100644
index 0000000..0b991d2
--- /dev/null
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/CompositeKeyTests.h
@@ -0,0 +1,38 @@
+/****************************************************************
+
+  Generated by Eclipse Cyclone DDS IDL to C Translator
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/CompositeKeyTests.h
+  Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\CompositeKeyTests.idl
+  Cyclone DDS: V0.11.0
+
+*****************************************************************/
+#ifndef DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_COMPOSITEKEYTESTS_H_B59754F81535499AA5283968B987B347
+#define DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_COMPOSITEKEYTESTS_H_B59754F81535499AA5283968B987B347
+
+#include "dds/ddsc/dds_public_impl.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct CycloneDDS_Runtime_Tests_CompositeKeyMessage
+{
+  int32_t part1;
+  int32_t part2;
+  char * part3;
+  double value;
+} CycloneDDS_Runtime_Tests_CompositeKeyMessage;
+
+extern const dds_topic_descriptor_t CycloneDDS_Runtime_Tests_CompositeKeyMessage_desc;
+
+#define CycloneDDS_Runtime_Tests_CompositeKeyMessage__alloc() \
+((CycloneDDS_Runtime_Tests_CompositeKeyMessage*) dds_alloc (sizeof (CycloneDDS_Runtime_Tests_CompositeKeyMessage)));
+
+#define CycloneDDS_Runtime_Tests_CompositeKeyMessage_free(d,o) \
+dds_sample_free ((d), &CycloneDDS_Runtime_Tests_CompositeKeyMessage_desc, (o))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_COMPOSITEKEYTESTS_H_B59754F81535499AA5283968B987B347 */
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.c b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.c
index d85d232..ca3e09c 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.c
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.c
@@ -1,7 +1,7 @@
 /****************************************************************
 
   Generated by Eclipse Cyclone DDS IDL to C Translator
-  File name: d:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\temp_c/KeyedTestMessage.c
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/KeyedTestMessage.c
   Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\KeyedTestMessage.idl
   Cyclone DDS: V0.11.0
 
@@ -15,13 +15,12 @@ __pragma(warning(disable: 5287))
 static const uint32_t CycloneDDS_Runtime_Tests_KeyedTestMessage_ops [] =
 {
   /* KeyedTestMessage */
-  DDS_OP_DLC,
   DDS_OP_ADR | DDS_OP_FLAG_KEY | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_KeyedTestMessage, sensorId),
   DDS_OP_ADR | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_KeyedTestMessage, value),
   DDS_OP_RTS,
   
   /* key: sensorId */
-  DDS_OP_KOF | 1, 1u /* order: 0 */
+  DDS_OP_KOF | 1, 0u /* order: 0 */
 };
 
 #if defined(_MSC_VER) && (_MSC_VER > 1943)
@@ -29,31 +28,31 @@ __pragma(warning(pop))
 #endif
 static const dds_key_descriptor_t CycloneDDS_Runtime_Tests_KeyedTestMessage_keys[1] =
 {
-  { "sensorId", 6, 0 }
+  { "sensorId", 5, 0 }
 };
 
 /* Type Information:
-  [MINIMAL da5e1eddee069c44a39803485ace] (#deps: 0)
-  [COMPLETE 39b116b8601d4bf504f5844643cd] (#deps: 0)
+  [MINIMAL ca65af29863d4009a661804688fa] (#deps: 0)
+  [COMPLETE 539ee398c79e0ffe2eb7ccbbe33d] (#deps: 0)
 */
 #define TYPE_INFO_CDR_CycloneDDS_Runtime_Tests_KeyedTestMessage (const unsigned char []){ \
   0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
-  0x14, 0x00, 0x00, 0x00, 0xf1, 0xda, 0x5e, 0x1e, 0xdd, 0xee, 0x06, 0x9c, 0x44, 0xa3, 0x98, 0x03, \
-  0x48, 0x5a, 0xce, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf1, 0xca, 0x65, 0xaf, 0x29, 0x86, 0x3d, 0x40, 0x09, 0xa6, 0x61, 0x80, \
+  0x46, 0x88, 0xfa, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
   0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
-  0x14, 0x00, 0x00, 0x00, 0xf2, 0x39, 0xb1, 0x16, 0xb8, 0x60, 0x1d, 0x4b, 0xf5, 0x04, 0xf5, 0x84, \
-  0x46, 0x43, 0xcd, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf2, 0x53, 0x9e, 0xe3, 0x98, 0xc7, 0x9e, 0x0f, 0xfe, 0x2e, 0xb7, 0xcc, \
+  0xbb, 0xe3, 0x3d, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
   0x00, 0x00, 0x00, 0x00\
 }
 #define TYPE_INFO_CDR_SZ_CycloneDDS_Runtime_Tests_KeyedTestMessage 100u
 #define TYPE_MAP_CDR_CycloneDDS_Runtime_Tests_KeyedTestMessage (const unsigned char []){ \
-  0x4b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0xda, 0x5e, 0x1e, 0xdd, 0xee, 0x06, 0x9c, \
-  0x44, 0xa3, 0x98, 0x03, 0x48, 0x5a, 0xce, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, \
+  0x4b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0xca, 0x65, 0xaf, 0x29, 0x86, 0x3d, 0x40, \
+  0x09, 0xa6, 0x61, 0x80, 0x46, 0x88, 0xfa, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, \
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, \
   0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x04, 0x39, 0xde, 0x4a, 0xa7, 0x00, \
   0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x20, 0x63, 0xc1, 0x60, 0x00, \
-  0x94, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x39, 0xb1, 0x16, 0xb8, 0x60, 0x1d, 0x4b, \
-  0xf5, 0x04, 0xf5, 0x84, 0x46, 0x43, 0xcd, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, \
+  0x94, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x53, 0x9e, 0xe3, 0x98, 0xc7, 0x9e, 0x0f, \
+  0xfe, 0x2e, 0xb7, 0xcc, 0xbb, 0xe3, 0x3d, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, \
   0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x43, 0x79, 0x63, 0x6c, \
   0x6f, 0x6e, 0x65, 0x44, 0x44, 0x53, 0x3a, 0x3a, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x3a, \
   0x3a, 0x54, 0x65, 0x73, 0x74, 0x73, 0x3a, 0x3a, 0x4b, 0x65, 0x79, 0x65, 0x64, 0x54, 0x65, 0x73, \
@@ -62,8 +61,8 @@ static const dds_key_descriptor_t CycloneDDS_Runtime_Tests_KeyedTestMessage_keys
   0x09, 0x00, 0x00, 0x00, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x49, 0x64, 0x00, 0x00, 0x00, 0x00, \
   0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, \
   0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, \
-  0xf2, 0x39, 0xb1, 0x16, 0xb8, 0x60, 0x1d, 0x4b, 0xf5, 0x04, 0xf5, 0x84, 0x46, 0x43, 0xcd, 0xf1, \
-  0xda, 0x5e, 0x1e, 0xdd, 0xee, 0x06, 0x9c, 0x44, 0xa3, 0x98, 0x03, 0x48, 0x5a, 0xce\
+  0xf2, 0x53, 0x9e, 0xe3, 0x98, 0xc7, 0x9e, 0x0f, 0xfe, 0x2e, 0xb7, 0xcc, 0xbb, 0xe3, 0x3d, 0xf1, \
+  0xca, 0x65, 0xaf, 0x29, 0x86, 0x3d, 0x40, 0x09, 0xa6, 0x61, 0x80, 0x46, 0x88, 0xfa\
 }
 #define TYPE_MAP_CDR_SZ_CycloneDDS_Runtime_Tests_KeyedTestMessage 270u
 const dds_topic_descriptor_t CycloneDDS_Runtime_Tests_KeyedTestMessage_desc =
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.h b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.h
index ac6f54f..6f5b8f0 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.h
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/KeyedTestMessage.h
@@ -1,13 +1,13 @@
 /****************************************************************
 
   Generated by Eclipse Cyclone DDS IDL to C Translator
-  File name: d:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\temp_c/KeyedTestMessage.h
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/KeyedTestMessage.h
   Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\KeyedTestMessage.idl
   Cyclone DDS: V0.11.0
 
 *****************************************************************/
-#ifndef DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_B4AD8A3EC8C8216EC78555081C46343E
-#define DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_B4AD8A3EC8C8216EC78555081C46343E
+#ifndef DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_EAE48755E6F14C43A7660587AFF7EF5E
+#define DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_EAE48755E6F14C43A7660587AFF7EF5E
 
 #include "dds/ddsc/dds_public_impl.h"
 
@@ -33,4 +33,4 @@ dds_sample_free ((d), &CycloneDDS_Runtime_Tests_KeyedTestMessage_desc, (o))
 }
 #endif
 
-#endif /* DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_B4AD8A3EC8C8216EC78555081C46343E */
+#endif /* DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_KEYEDTESTMESSAGE_H_EAE48755E6F14C43A7660587AFF7EF5E */
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.c b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.c
index d8f1bd5..d84054e 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.c
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.c
@@ -1,7 +1,7 @@
 /****************************************************************
 
   Generated by Eclipse Cyclone DDS IDL to C Translator
-  File name: d:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\temp_c/TestMessage.c
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/TestMessage.c
   Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\TestMessage.idl
   Cyclone DDS: V0.11.0
 
@@ -15,7 +15,6 @@ __pragma(warning(disable: 5287))
 static const uint32_t CycloneDDS_Runtime_Tests_TestMessage_ops [] =
 {
   /* TestMessage */
-  DDS_OP_DLC,
   DDS_OP_ADR | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_TestMessage, id),
   DDS_OP_ADR | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN, offsetof (CycloneDDS_Runtime_Tests_TestMessage, value),
   DDS_OP_RTS
@@ -25,27 +24,27 @@ static const uint32_t CycloneDDS_Runtime_Tests_TestMessage_ops [] =
 __pragma(warning(pop))
 #endif
 /* Type Information:
-  [MINIMAL c57cdef4f903abc2cb7eaa40561f] (#deps: 0)
-  [COMPLETE eae77f2af8fcc2e13ce856c54b19] (#deps: 0)
+  [MINIMAL b3bf78b6075e7c906b83a7106548] (#deps: 0)
+  [COMPLETE 7a6d47c7587b703d6a65415c6ef7] (#deps: 0)
 */
 #define TYPE_INFO_CDR_CycloneDDS_Runtime_Tests_TestMessage (const unsigned char []){ \
   0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
-  0x14, 0x00, 0x00, 0x00, 0xf1, 0xc5, 0x7c, 0xde, 0xf4, 0xf9, 0x03, 0xab, 0xc2, 0xcb, 0x7e, 0xaa, \
-  0x40, 0x56, 0x1f, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf1, 0xb3, 0xbf, 0x78, 0xb6, 0x07, 0x5e, 0x7c, 0x90, 0x6b, 0x83, 0xa7, \
+  0x10, 0x65, 0x48, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
   0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, \
-  0x14, 0x00, 0x00, 0x00, 0xf2, 0xea, 0xe7, 0x7f, 0x2a, 0xf8, 0xfc, 0xc2, 0xe1, 0x3c, 0xe8, 0x56, \
-  0xc5, 0x4b, 0x19, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
+  0x14, 0x00, 0x00, 0x00, 0xf2, 0x7a, 0x6d, 0x47, 0xc7, 0x58, 0x7b, 0x70, 0x3d, 0x6a, 0x65, 0x41, \
+  0x5c, 0x6e, 0xf7, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, \
   0x00, 0x00, 0x00, 0x00\
 }
 #define TYPE_INFO_CDR_SZ_CycloneDDS_Runtime_Tests_TestMessage 100u
 #define TYPE_MAP_CDR_CycloneDDS_Runtime_Tests_TestMessage (const unsigned char []){ \
-  0x4b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0xc5, 0x7c, 0xde, 0xf4, 0xf9, 0x03, 0xab, \
-  0xc2, 0xcb, 0x7e, 0xaa, 0x40, 0x56, 0x1f, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x02, 0x00, \
+  0x4b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0xb3, 0xbf, 0x78, 0xb6, 0x07, 0x5e, 0x7c, \
+  0x90, 0x6b, 0x83, 0xa7, 0x10, 0x65, 0x48, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, \
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, \
   0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0xb8, 0x0b, 0xb7, 0x74, 0x00, \
   0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x20, 0x63, 0xc1, 0x60, 0x00, \
-  0x88, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0xea, 0xe7, 0x7f, 0x2a, 0xf8, 0xfc, 0xc2, \
-  0xe1, 0x3c, 0xe8, 0x56, 0xc5, 0x4b, 0x19, 0x00, 0x70, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x02, 0x00, \
+  0x88, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x7a, 0x6d, 0x47, 0xc7, 0x58, 0x7b, 0x70, \
+  0x3d, 0x6a, 0x65, 0x41, 0x5c, 0x6e, 0xf7, 0x00, 0x70, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, \
   0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x43, 0x79, 0x63, 0x6c, \
   0x6f, 0x6e, 0x65, 0x44, 0x44, 0x53, 0x3a, 0x3a, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x3a, \
   0x3a, 0x54, 0x65, 0x73, 0x74, 0x73, 0x3a, 0x3a, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x65, 0x73, 0x73, \
@@ -53,9 +52,9 @@ __pragma(warning(pop))
   0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x69, 0x64, 0x00, 0x00, \
   0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, \
   0x06, 0x00, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, \
-  0x01, 0x00, 0x00, 0x00, 0xf2, 0xea, 0xe7, 0x7f, 0x2a, 0xf8, 0xfc, 0xc2, 0xe1, 0x3c, 0xe8, 0x56, \
-  0xc5, 0x4b, 0x19, 0xf1, 0xc5, 0x7c, 0xde, 0xf4, 0xf9, 0x03, 0xab, 0xc2, 0xcb, 0x7e, 0xaa, 0x40, \
-  0x56, 0x1f\
+  0x01, 0x00, 0x00, 0x00, 0xf2, 0x7a, 0x6d, 0x47, 0xc7, 0x58, 0x7b, 0x70, 0x3d, 0x6a, 0x65, 0x41, \
+  0x5c, 0x6e, 0xf7, 0xf1, 0xb3, 0xbf, 0x78, 0xb6, 0x07, 0x5e, 0x7c, 0x90, 0x6b, 0x83, 0xa7, 0x10, \
+  0x65, 0x48\
 }
 #define TYPE_MAP_CDR_SZ_CycloneDDS_Runtime_Tests_TestMessage 258u
 const dds_topic_descriptor_t CycloneDDS_Runtime_Tests_TestMessage_desc =
diff --git a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.h b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.h
index bdbc925..41c23c8 100644
--- a/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.h
+++ b/tests/CycloneDDS.Runtime.Tests/Gen/temp_c/TestMessage.h
@@ -1,13 +1,13 @@
 /****************************************************************
 
   Generated by Eclipse Cyclone DDS IDL to C Translator
-  File name: d:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\temp_c/TestMessage.h
+  File name: tests\CycloneDDS.Runtime.Tests\Gen\temp_c/TestMessage.h
   Source: D:\Work\FastCycloneDdsCsharpBindings\tests\CycloneDDS.Runtime.Tests\Gen\TestMessage.idl
   Cyclone DDS: V0.11.0
 
 *****************************************************************/
-#ifndef DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_6A667A0FAF8F97FD7EF7D4B4B64FDDCD
-#define DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_6A667A0FAF8F97FD7EF7D4B4B64FDDCD
+#ifndef DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_4B544EAA31E2E85598F548C898E9E3A0
+#define DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_4B544EAA31E2E85598F548C898E9E3A0
 
 #include "dds/ddsc/dds_public_impl.h"
 
@@ -33,4 +33,4 @@ dds_sample_free ((d), &CycloneDDS_Runtime_Tests_TestMessage_desc, (o))
 }
 #endif
 
-#endif /* DDSC_D__WORK_FASTCYCLONEDDSCSHARPBINDINGS_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_6A667A0FAF8F97FD7EF7D4B4B64FDDCD */
+#endif /* DDSC_TESTS_CYCLONEDDS_RUNTIME_TESTS_GEN_TEMP_C_TESTMESSAGE_H_4B544EAA31E2E85598F548C898E9E3A0 */
diff --git a/tests/CycloneDDS.Runtime.Tests/InstanceManagementTests.cs b/tests/CycloneDDS.Runtime.Tests/InstanceManagementTests.cs
index 1436fee..b52ec05 100644
--- a/tests/CycloneDDS.Runtime.Tests/InstanceManagementTests.cs
+++ b/tests/CycloneDDS.Runtime.Tests/InstanceManagementTests.cs
@@ -134,7 +134,7 @@ namespace CycloneDDS.Runtime.Tests
                 }
                 for(int i=0; i< initScope.Count; i++)
                 {
-                     if (initScope[i].SensorId == 1)
+                     if (initScope.Infos[i].ValidData != 0 && initScope[i].SensorId == 1)
                      {
                          handle1 = new DdsInstanceHandle(initScope.Infos[i].InstanceHandle);
                          break;
@@ -147,9 +147,12 @@ namespace CycloneDDS.Runtime.Tests
             using var scope = reader.ReadInstance(handle1);
             
             Assert.True(scope.Count > 0);
-            foreach(var item in scope)
+            for (int i = 0; i < scope.Count; i++)
             {
-                Assert.Equal(1, item.SensorId);
+                if (scope.Infos[i].ValidData != 0)
+                {
+                    Assert.Equal(1, scope[i].SensorId);
+                }
             }
         }
     }
diff --git a/tools/CycloneDDS.CodeGen/DeserializerEmitter.cs b/tools/CycloneDDS.CodeGen/DeserializerEmitter.cs
index f455e43..d442b55 100644
--- a/tools/CycloneDDS.CodeGen/DeserializerEmitter.cs
+++ b/tools/CycloneDDS.CodeGen/DeserializerEmitter.cs
@@ -586,18 +586,26 @@ namespace CycloneDDS.CodeGen
             
             return typeName.ToLower() switch
             {
-                "byte" or "uint8" or "sbyte" or "int8" or "bool" or "boolean" => 1,
-                "short" or "int16" or "ushort" or "uint16" => 2,
-                "int" or "int32" or "uint" or "uint32" or "float" or
+                "byte" or "uint8" or "sbyte" or "int8" or "bool" or "boolean" or
+                "system.byte" or "system.sbyte" or "system.boolean" => 1,
+                
+                "short" or "int16" or "ushort" or "uint16" or "char" or
+                "system.int16" or "system.uint16" or "system.char" => 2,
+                
+                "int" or "int32" or "uint" or "uint32" or "float" or "single" or
+                "system.int32" or "system.uint32" or "system.single" or
                 "vector2" or "system.numerics.vector2" or
                 "vector3" or "system.numerics.vector3" or
                 "vector4" or "system.numerics.vector4" or
                 "quaternion" or "system.numerics.quaternion" or
                 "matrix4x4" or "system.numerics.matrix4x4" => 4,
+                
                 "long" or "int64" or "ulong" or "uint64" or "double" or
-                "datetime" or "system.datetime" or "timespan" or "system.timespan" => 8,
-                "guid" or "system.guid" => 1,
+                "system.int64" or "system.uint64" or "system.double" or
+                "datetime" or "system.datetime" or "timespan" or "system.timespan" or
                 "datetimeoffset" or "system.datetimeoffset" => 8,
+                
+                "guid" or "system.guid" => 1,
                 _ => 1
             };
         }
diff --git a/tools/CycloneDDS.CodeGen/IdlEmitter.cs b/tools/CycloneDDS.CodeGen/IdlEmitter.cs
index 6026261..dcf0d50 100644
--- a/tools/CycloneDDS.CodeGen/IdlEmitter.cs
+++ b/tools/CycloneDDS.CodeGen/IdlEmitter.cs
@@ -204,7 +204,7 @@ namespace CycloneDDS.CodeGen
             string indent = GetIndent(indentLevel);
             string fieldIndent = GetIndent(indentLevel + 1);
 
-            sb.AppendLine($"{indent}@appendable");
+            sb.AppendLine($"{indent}@final");
             sb.AppendLine($"{indent}struct {type.Name} {{");
             
             foreach (var field in type.Fields)
diff --git a/tools/CycloneDDS.CodeGen/ManagedTypeValidator.cs b/tools/CycloneDDS.CodeGen/ManagedTypeValidator.cs
index 83a36dc..cb41b5d 100644
--- a/tools/CycloneDDS.CodeGen/ManagedTypeValidator.cs
+++ b/tools/CycloneDDS.CodeGen/ManagedTypeValidator.cs
@@ -47,12 +47,12 @@ namespace CycloneDDS.CodeGen
         
         private bool HasDdsManagedAttribute(TypeInfo type)
         {
-            return type.Attributes?.Any(a => a.Name == "DdsManaged") ?? false;
+            return type.Attributes?.Any(a => a.Name == "DdsManaged" || a.Name == "DdsManagedAttribute") ?? false;
         }
         
         private bool HasDdsManagedAttribute(FieldInfo field)
         {
-            return field.Attributes?.Any(a => a.Name == "DdsManaged") ?? false;
+            return field.Attributes?.Any(a => a.Name == "DdsManaged" || a.Name == "DdsManagedAttribute") ?? false;
         }
     }
 
diff --git a/tools/CycloneDDS.CodeGen/SchemaDiscovery.cs b/tools/CycloneDDS.CodeGen/SchemaDiscovery.cs
index 09c834a..5d6023f 100644
--- a/tools/CycloneDDS.CodeGen/SchemaDiscovery.cs
+++ b/tools/CycloneDDS.CodeGen/SchemaDiscovery.cs
@@ -281,11 +281,15 @@ namespace CycloneDDS.CodeGen
             var format = new SymbolDisplayFormat(
                 typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                 genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters);
+            
+            string typeName = type.ToDisplayString(format);
+            // Normalize System.String to string for consistency with emitters
+            typeName = typeName.Replace("System.String", "string");
 
             return new FieldInfo
             {
                 Name = member.Name,
-                TypeName = type.ToDisplayString(format),
+                TypeName = typeName,
                 Attributes = ExtractAttributes(member)
             };
         }
diff --git a/tools/CycloneDDS.CodeGen/SerializerEmitter.cs b/tools/CycloneDDS.CodeGen/SerializerEmitter.cs
index 83868dc..1832ddf 100644
--- a/tools/CycloneDDS.CodeGen/SerializerEmitter.cs
+++ b/tools/CycloneDDS.CodeGen/SerializerEmitter.cs
@@ -658,17 +658,25 @@ namespace CycloneDDS.CodeGen
             
             return typeName.ToLower() switch
             {
-                "byte" or "uint8" or "sbyte" or "int8" or "bool" or "boolean" => 1,
-                "short" or "int16" or "ushort" or "uint16" => 2,
-                "int" or "int32" or "uint" or "uint32" or "float" or
+                "byte" or "uint8" or "sbyte" or "int8" or "bool" or "boolean" or
+                "system.byte" or "system.sbyte" or "system.boolean" => 1,
+                
+                "short" or "int16" or "ushort" or "uint16" or "char" or
+                "system.int16" or "system.uint16" or "system.char" => 2,
+                
+                "int" or "int32" or "uint" or "uint32" or "float" or "single" or
+                "system.int32" or "system.uint32" or "system.single" or
                 "system.numerics.vector2" or
                 "system.numerics.vector3" or
                 "system.numerics.vector4" or
                 "system.numerics.quaternion" or
                 "system.numerics.matrix4x4" => 4,
+                
                 "long" or "int64" or "ulong" or "uint64" or "double" or
+                "system.int64" or "system.uint64" or "system.double" or
                 "system.datetime" or "system.timespan" or
                 "system.datetimeoffset" => 8,
+                
                 "system.guid" => 1,
                 _ => 1
             };
-- 
2.50.1.windows.1

