From 5631350ecc44e313286f0c4be37104e8d762729c Mon Sep 17 00:00:00 2001
From: pjanec <pjanec@hotmail.com>
Date: Mon, 19 Jan 2026 17:57:56 +0100
Subject: [PATCH 2/2] wip: BATCH 20. lots of debug prints to find out the
 reason for crashing

The assertion failure assert \(!is\_key\) at line 166 of dds\_cdrstream\_keys.part.h \(referenced internally as `dds_cdr`\) occurs when the native serializer encounters a **Key** field that is marked as **Optional** but is either missing from the stream or processed in XCDR1 mode \(where keys cannot be optional\).

I found that the generated descriptor for KeyedTestMessage was incorrectly flagging the SensorId key field as `OPTIONAL`.

### Analysis of the Fix

1. **Crash Location**: `dds_cdrstream_keys.part.h:166` inside dds\_stream\_extract\_keyBO\_from\_data\_adr.
    - Logic: if \(optional && \(missing || xcdr1\)\) \{ assert\(!is\_key\); \}
    - Cause: SensorId was defined with flags `0x21` \(DDS\_OP\_FLAG\_KEY | DDS\_OP\_FLAG\_OPT\).
2. **Incorrect Descriptor**: In KeyedTestMessage.Descriptor.cs, the \_ops array contained `16973857` \(`0x01030021`\).
    - `0x01` = `ADR` \(Address/Field\)
    - `0x03` = `4BY` \(4-byte Integer, matching int SensorId\)
    - `0x21` = `KEY` \(Correct\) | `OPTIONAL` \(Incorrect for a non-nullable `int`\).
3. **Resolution**: I patched the descriptor to remove the `OPTIONAL` flag.
    - Old Opcode: `16973857` \(`...21`\)
    - New Opcode: `16973825` \(`...01` -&gt; Just `KEY`\)
    - I confirmed that OpIndex = 0 is the correct starting index for this bytecode array.

I have applied the fix directly to the generated file in the Runtime.Tests project.

**Note**: Since KeyedTestMessage.Descriptor.cs is a generated file, this fix confirms the issue is in the C# Generator logic \(likely marking all struct fields as optional via `DDS_OP_FLAG_OPT`\). You may need to investigate the generator \(CycloneDDS.CodeGen\) to prevent this from recurring on regeneration.

You can now run your tests again.

1. **Instruction Patch**:
    - **File**: KeyedTestMessage.Descriptor.cs
    - **Change**: Updated \_ops\[0\] from `16973857` to `16973825`.

The OpIndex should remain `0` \(pointing to the valid start of the array\). The previous "Outside bounds" crashes when using OpIndex=5 or `6` were expected as the array length is only 5.
---
 src/core/cdr/src/dds_cdrstream.c           |  8 ++++
 src/core/cdr/src/dds_cdrstream_keys.part.h |  4 ++
 src/core/ddsc/src/dds_instance.c           | 34 +++++++++++-----
 src/core/ddsc/src/dds_participant.c        | 46 ++++++++++++++++++++--
 src/core/ddsc/src/dds_topic.c              | 31 +++++++++++++--
 src/core/ddsi/src/ddsi_tkmap.c             | 13 ++++++
 6 files changed, 120 insertions(+), 16 deletions(-)

diff --git a/src/core/cdr/src/dds_cdrstream.c b/src/core/cdr/src/dds_cdrstream.c
index 1b94810e..bb76906b 100644
--- a/src/core/cdr/src/dds_cdrstream.c
+++ b/src/core/cdr/src/dds_cdrstream.c
@@ -7055,19 +7055,25 @@ static const uint32_t *dds_stream_get_memberid_table (const struct dds_cdrstream
 void dds_cdrstream_desc_init_with_nops (struct dds_cdrstream_desc *desc, const struct dds_cdrstream_allocator *allocator,
     uint32_t size, uint32_t align, uint32_t flagset, const uint32_t *ops, uint32_t nops, const dds_key_descriptor_t *keys, uint32_t nkeys)
 {
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_cdr.log", "a");
+  if(f) { fprintf(f, "dds_cdrstream_desc_init_with_nops: nops=%d, nkeys=%d, keys[0].m_offset=%d\n", nops, nkeys, nkeys>0?keys[0].m_offset:-1); fflush(f); }
+
   desc->size = size;
   desc->align = align;
 
   /* Copy keys from topic descriptor, which are ordered by member-id (scoped to their containing
      type. Additionally a copy of the key list in definition order is stored. */
   desc->keys.nkeys = nkeys;
+  if(f) { fprintf(f, "Calling copy_desc_keys\n"); fflush(f); }
   copy_desc_keys (&desc->keys.keys, allocator, keys, nkeys);
   copy_desc_keys (&desc->keys.keys_definition_order, allocator, keys, nkeys);
   if (desc->keys.nkeys > 0)
     qsort (desc->keys.keys_definition_order, nkeys, sizeof (*desc->keys.keys_definition_order), key_cmp_idx);
 
   /* Get the actual number of ops, excluding the member ID table ops */
+  if(f) { fprintf(f, "Calling dds_stream_countops\n"); fflush(f); }
   uint32_t counted_ops = dds_stream_countops (ops, nkeys, keys);
+  if(f) { fprintf(f, "counted_ops=%d\n", counted_ops); fflush(f); }
   desc->ops.nops = (counted_ops < nops) ? nops : counted_ops;
 
   /* Copy all ops, including the member ID table (if present) */
@@ -7104,7 +7110,9 @@ void dds_cdrstream_desc_init_with_nops (struct dds_cdrstream_desc *desc, const s
   /* Get the flagset from the descriptor, except for the key related flags that are calculated
      using the CDR stream serializer */
   desc->flagset = flagset & ~DDS_CDR_CALCULATED_FLAGS;
+  if(f) { fprintf(f, "Calling dds_stream_key_flags\n"); fflush(f); }
   desc->flagset |= dds_stream_key_flags (desc, NULL, NULL);
+  if(f) { fprintf(f, "dds_cdrstream_desc_init_with_nops done\n"); fclose(f); }
 }
 
 void dds_cdrstream_desc_init (struct dds_cdrstream_desc *desc, const struct dds_cdrstream_allocator *allocator,
diff --git a/src/core/cdr/src/dds_cdrstream_keys.part.h b/src/core/cdr/src/dds_cdrstream_keys.part.h
index 2140f3ef..7dafd8b5 100644
--- a/src/core/cdr/src/dds_cdrstream_keys.part.h
+++ b/src/core/cdr/src/dds_cdrstream_keys.part.h
@@ -85,6 +85,9 @@ static bool dds_stream_write_keyBO_impl (RESTRICT_OSTREAM_T *os, const struct dd
 ddsrt_attribute_warn_unused_result ddsrt_nonnull_all
 static bool dds_stream_write_keyBO_restrict (RESTRICT_OSTREAM_T *os, enum dds_cdr_key_serialization_kind ser_kind, const struct dds_cdrstream_allocator *allocator, const char *sample, const struct dds_cdrstream_desc *desc)
 {
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_keys.log", "a");
+  if(f) { fprintf(f, "dds_stream_write_keyBO_restrict: nkeys=%d\n", desc->keys.nkeys); fflush(f); }
+
   if (desc->flagset & (DDS_TOPIC_KEY_APPENDABLE | DDS_TOPIC_KEY_MUTABLE | DDS_TOPIC_KEY_SEQUENCE | DDS_TOPIC_KEY_ARRAY_NONPRIM) && ser_kind == DDS_CDR_KEY_SERIALIZATION_SAMPLE)
   {
     /* For types with key fields in aggregated types with appendable or mutable
@@ -106,6 +109,7 @@ static bool dds_stream_write_keyBO_restrict (RESTRICT_OSTREAM_T *os, enum dds_cd
     struct dds_cdrstream_desc_key *keylist = use_memberid_order ? desc->keys.keys : desc->keys.keys_definition_order;
     for (uint32_t i = 0; i < desc->keys.nkeys; i++)
     {
+      if(f) { fprintf(f, "  processing key i=%d, ops_offs=%d\n", i, keylist[i].ops_offs); fflush(f); }
       const uint32_t *insnp = desc->ops.ops + keylist[i].ops_offs;
       switch (DDS_OP (*insnp))
       {
diff --git a/src/core/ddsc/src/dds_instance.c b/src/core/ddsc/src/dds_instance.c
index d6583acd..2804383b 100644
--- a/src/core/ddsc/src/dds_instance.c
+++ b/src/core/ddsc/src/dds_instance.c
@@ -343,29 +343,45 @@ dds_return_t dds_instance_get_key (dds_entity_t entity, dds_instance_handle_t ih
   return ret;
 }
 
+
 DDS_EXPORT dds_instance_handle_t dds_lookup_instance_serdata (dds_entity_t entity, const struct ddsi_serdata *sd)
 {
-  // DEBUG LOG
-  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_log.txt", "a");
-  if(f) { fprintf(f, "DEBUG: dds_lookup_instance_serdata entered. entity=%d, sd=%p\n", entity, sd); fclose(f); }
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_instance.log", "a");
+  if(f) { fprintf(f, "START: dds_lookup_instance_serdata. entity=%d, sd=%p\n", entity, sd); fflush(f); }
 
   dds_entity *w_or_r;
 
-  if (sd == NULL)
-    return DDS_HANDLE_NIL;
+  if (sd == NULL) {
+      if(f) { fprintf(f, "ERROR: sd is NULL\n"); fclose(f); }
+      return DDS_HANDLE_NIL;
+  }
 
-  if (dds_entity_lock (entity, DDS_KIND_DONTCARE, &w_or_r) < 0)
-    return DDS_HANDLE_NIL;
+  if (dds_entity_lock (entity, DDS_KIND_DONTCARE, &w_or_r) < 0) {
+      if(f) { fprintf(f, "ERROR: dds_entity_lock failed\n"); fclose(f); }
+      return DDS_HANDLE_NIL;
+  }
 
   dds_instance_handle_t ih;
   struct ddsi_thread_state * const thrst = ddsi_lookup_thread_state ();
   ddsi_thread_state_awake (thrst, &w_or_r->m_domain->gv);
   
-  if(f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_log.txt", "a")) { fprintf(f, "DEBUG: Calling ddsi_tkmap_lookup\n"); fclose(f); }
+  if(f) { 
+      fprintf(f, "Validation: w_or_r=%p\n", w_or_r);
+      if(w_or_r) fprintf(f, "Validation: w_or_r->m_domain=%p\n", w_or_r->m_domain);
+      // Note: gv is a struct instance, not a pointer in most cases, but let's check assumptions
+      // w_or_r->m_domain->gv is struct ddsi_domaingv
+      // w_or_r->m_domain->gv.m_tkmap is struct ddsi_tkmap *
+      if(w_or_r && w_or_r->m_domain) fprintf(f, "Validation: tkmap=%p\n", w_or_r->m_domain->gv.m_tkmap);
+      fprintf(f, "DEBUG: Calling ddsi_tkmap_lookup\n"); 
+      fflush(f); 
+  }
+
   ih = ddsi_tkmap_lookup (w_or_r->m_domain->gv.m_tkmap, sd);
-  if(f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_log.txt", "a")) { fprintf(f, "DEBUG: ddsi_tkmap_lookup returned %lld\n", (long long)ih); fclose(f); }
+  
+  if(f) { fprintf(f, "DEBUG: ddsi_tkmap_lookup returned %lld\n", (long long)ih); fclose(f); }
   
   ddsi_thread_state_asleep (thrst);
   dds_entity_unlock (w_or_r);
   return ih;
 }
+
diff --git a/src/core/ddsc/src/dds_participant.c b/src/core/ddsc/src/dds_participant.c
index c6bfa64a..9f41d674 100644
--- a/src/core/ddsc/src/dds_participant.c
+++ b/src/core/ddsc/src/dds_participant.c
@@ -10,6 +10,7 @@
 
 #include <assert.h>
 #include <string.h>
+#include <stdio.h>
 
 #include "dds/ddsrt/cdtors.h"
 #include "dds/ddsrt/environ.h"
@@ -95,6 +96,9 @@ const struct dds_entity_deriver dds_entity_deriver_participant = {
 
 static dds_entity_t create_participant_flags_guid (const dds_domainid_t domain, const dds_qos_t *qos, const dds_listener_t *listener, uint32_t flags, const dds_guid_t *guid)
 {
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_participant.log", "a");
+  if(f) { fprintf(f, "START: create_participant_flags_guid domain=%d\n", domain); fflush(f); }
+
   dds_domain *dom;
   dds_entity_t ret;
   ddsi_guid_t ddsi_guid;
@@ -104,13 +108,21 @@ static dds_entity_t create_participant_flags_guid (const dds_domainid_t domain,
   const char *config = "";
 
   /* Make sure DDS instance is initialized. */
-  if ((ret = dds_init ()) < 0)
+  if(f) { fprintf(f, "Calling dds_init\n"); fflush(f); }
+  if ((ret = dds_init ()) < 0) {
+    if(f) { fprintf(f, "dds_init failed: %d\n", ret); fclose(f); }
     goto err_dds_init;
+  }
+  if(f) { fprintf(f, "dds_init success\n"); fflush(f); }
 
   (void) ddsrt_getenv ("CYCLONEDDS_URI", &config);
 
-  if ((ret = dds_domain_create_internal (&dom, domain, true, config)) < 0)
+  if(f) { fprintf(f, "Calling dds_domain_create_internal. config=%s\n", config ? config : "null"); fflush(f); }
+  if ((ret = dds_domain_create_internal (&dom, domain, true, config)) < 0) {
+    if(f) { fprintf(f, "dds_domain_create_internal failed: %d\n", ret); fclose(f); }
     goto err_domain_create;
+  }
+  if(f) { fprintf(f, "dds_domain_create_internal success. dom=%p\n", dom); fflush(f); }
 
   new_qos = dds_create_qos ();
   if (qos != NULL)
@@ -119,11 +131,16 @@ static dds_entity_t create_participant_flags_guid (const dds_domainid_t domain,
   dds_apply_entity_naming(new_qos, NULL, &dom->gv);
 
   if ((ret = ddsi_xqos_valid (&dom->gv.logconfig, new_qos)) < 0)
-    goto err_qos_validation;
+  {
+      if(f) { fprintf(f, "ddsi_xqos_valid failed\n"); fclose(f); }
+      goto err_qos_validation;
+  }
+    
   // generic validation code will check lease duration, we only need to check kind
   // is what we insist on
   if (new_qos->liveliness.kind != DDS_LIVELINESS_AUTOMATIC)
   {
+    if(f) { fprintf(f, "liveliness check failed\n"); fclose(f); }
     ret = DDS_RETCODE_BAD_PARAMETER;
     goto err_qos_validation;
   }
@@ -133,39 +150,60 @@ static dds_entity_t create_participant_flags_guid (const dds_domainid_t domain,
   ddsi_plist_init_empty (&plist);
   ddsi_xqos_mergein_missing (&plist.qos, new_qos, ~(uint64_t)0);
 
+  if(f) { fprintf(f, "Calling ddsi_new_participant\n"); fflush(f); }
+
   ddsi_thread_state_awake (ddsi_lookup_thread_state (), &dom->gv);
   if (guid)
     ddsi_guid = dds_guid_to_ddsi_guid (*guid);
   else
     ddsi_generate_participant_guid (&ddsi_guid, &dom->gv);
+  
   ret = ddsi_new_participant (&ddsi_guid, &dom->gv, flags, &plist);
+  
   ddsi_thread_state_asleep (ddsi_lookup_thread_state ());
   ddsi_plist_fini (&plist);
   if (ret < 0)
   {
+    if(f) { fprintf(f, "ddsi_new_participant failed: %d\n", ret); fclose(f); }
     ret = DDS_RETCODE_ERROR;
     goto err_new_participant;
   }
 
+  if(f) { fprintf(f, "ddsi_new_participant success\n"); fflush(f); }
+
   pp = dds_alloc (sizeof (*pp));
+  
+  if(f) { fprintf(f, "Calling dds_entity_init\n"); fflush(f); }
   if ((ret = dds_entity_init (&pp->m_entity, &dom->m_entity, DDS_KIND_PARTICIPANT, false, true, new_qos, listener, DDS_PARTICIPANT_STATUS_MASK)) < 0)
-    goto err_entity_init;
+  {
+      if(f) { fprintf(f, "dds_entity_init failed: %d\n", ret); fclose(f); }
+      goto err_entity_init;
+  }
+  if(f) { fprintf(f, "dds_entity_init success\n"); fflush(f); }
 
   pp->m_entity.m_guid = ddsi_guid;
   pp->m_entity.m_iid = ddsi_get_entity_instanceid (&dom->gv, &ddsi_guid);
   pp->m_entity.m_domain = dom;
   pp->m_builtin_subscriber = 0;
+  
+  if(f) { fprintf(f, "Calling ddsrt_avl_init\n"); fflush(f); }
   ddsrt_avl_init (&participant_ktopics_treedef, &pp->m_ktopics);
 
   /* Add participant to extent */
   ddsrt_mutex_lock (&dom->m_entity.m_mutex);
+  if(f) { fprintf(f, "Calling dds_entity_register_child\n"); fflush(f); }
   dds_entity_register_child (&dom->m_entity, &pp->m_entity);
   ddsrt_mutex_unlock (&dom->m_entity.m_mutex);
 
+  if(f) { fprintf(f, "Calling dds_entity_init_complete\n"); fflush(f); }
   dds_entity_init_complete (&pp->m_entity);
   /* drop temporary extra ref to domain, dds_init */
+  
+  if(f) { fprintf(f, "Cleaning up refs\n"); fflush(f); }
   dds_entity_unpin_and_drop_ref (&dom->m_entity);
   dds_entity_unpin_and_drop_ref (&dds_global.m_entity);
+  
+  if(f) { fprintf(f, "Finished create_participant_flags_guid (SUCCESS)\n"); fclose(f); }
   return ret;
 
 err_entity_init:
diff --git a/src/core/ddsc/src/dds_topic.c b/src/core/ddsc/src/dds_topic.c
index 1d7defe2..fe50e684 100644
--- a/src/core/ddsc/src/dds_topic.c
+++ b/src/core/ddsc/src/dds_topic.c
@@ -11,6 +11,7 @@
 #include <assert.h>
 #include <string.h>
 #include <ctype.h>
+#include <stdio.h>
 
 #include "dds/ddsrt/misc.h"
 #include "dds/ddsrt/atomics.h"
@@ -657,6 +658,9 @@ dds_entity_t dds_create_topic_sertype (dds_entity_t participant, const char *nam
 
 dds_entity_t dds_create_topic (dds_entity_t participant, const dds_topic_descriptor_t *descriptor, const char *name, const dds_qos_t *qos, const dds_listener_t *listener)
 {
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_topic.log", "a");
+  if(f) { fprintf(f, "START: dds_create_topic participant=%d, name=%s\n", participant, name); fflush(f); }
+
   struct dds_entity *ppent;
   dds_return_t ret;
 
@@ -670,6 +674,8 @@ dds_entity_t dds_create_topic (dds_entity_t participant, const dds_topic_descrip
   if (qos)
     ddsi_xqos_mergein_missing (tpqos, qos, DDS_TOPIC_QOS_MASK);
 
+  if(f) { fprintf(f, "Checking descriptor: m_size=%d, m_flagset=%d, m_ops=%p\n", descriptor->m_size, descriptor->m_flagset, descriptor->m_ops); fflush(f); }
+
   /* Check the data representation in the provided QoS for compatiblity with the extensibility
      of the types used in this topic. In case any functionality is used that we don't support in
      XCDR1 (extensibility mutable and appendable, optional members), the XCDR2 data representation
@@ -678,24 +684,43 @@ dds_entity_t dds_create_topic (dds_entity_t participant, const dds_topic_descrip
      QoS object. */
   uint32_t allowed_repr = descriptor->m_flagset & DDS_TOPIC_RESTRICT_DATA_REPRESENTATION ?
       descriptor->restrict_data_representation : DDS_DATA_REPRESENTATION_RESTRICT_DEFAULT;
+  
+  if(f) { fprintf(f, "Calling dds_stream_minimum_xcdr_version\n"); fflush(f); }
   uint16_t min_xcdrv = dds_stream_minimum_xcdr_version (descriptor->m_ops);
+  if(f) { fprintf(f, "min_xcdrv=%d\n", min_xcdrv); fflush(f); }
+  
   if (min_xcdrv == DDSI_RTPS_CDR_ENC_VERSION_2)
     allowed_repr &= ~DDS_DATA_REPRESENTATION_FLAG_XCDR1;
-  if ((ret = dds_ensure_valid_data_representation (tpqos, allowed_repr, dds_stream_data_types (descriptor->m_ops), DDS_KIND_TOPIC)) != DDS_RETCODE_OK)
-    goto err_data_repr;
+    
+  if(f) { fprintf(f, "Calling dds_stream_data_types\n"); fflush(f); }
+  uint32_t data_types = dds_stream_data_types (descriptor->m_ops);
+  if(f) { fprintf(f, "Calling dds_ensure_valid_data_representation\n"); fflush(f); }
+  
+  if ((ret = dds_ensure_valid_data_representation (tpqos, allowed_repr, data_types, DDS_KIND_TOPIC)) != DDS_RETCODE_OK)
+  {
+      if(f) { fprintf(f, "dds_ensure_valid_data_representation failed\n"); fclose(f); }
+      goto err_data_repr;
+  }
 
   assert (tpqos->present & DDSI_QP_DATA_REPRESENTATION && tpqos->data_representation.value.n > 0);
   dds_data_representation_id_t data_representation = tpqos->data_representation.value.ids[0];
-
+  
+  if(f) { fprintf(f, "Calling ddsrt_malloc\n"); fflush(f); }
   struct dds_sertype_default *st = ddsrt_malloc (sizeof (*st));
+  
+  if(f) { fprintf(f, "Calling dds_sertype_default_init\n"); fflush(f); }
   if ((ret = dds_sertype_default_init (ppent->m_domain, st, descriptor, min_xcdrv, data_representation)) < 0)
   {
+    if(f) { fprintf(f, "dds_sertype_default_init failed\n"); fclose(f); }
     ddsrt_free (st);
     goto err_st_init;
   }
 
   struct ddsi_sertype *st_tmp = &st->c;
+  if(f) { fprintf(f, "Calling dds_create_topic_impl\n"); fflush(f); }
   dds_entity_t hdl = dds_create_topic_impl (participant, name, false, &st_tmp, tpqos, listener, false);
+  if(f) { fprintf(f, "dds_create_topic_impl returned %d\n", hdl); fclose(f); }
+  
   if (hdl < 0)
     ddsi_sertype_unref (st_tmp);
   ret = hdl;
diff --git a/src/core/ddsi/src/ddsi_tkmap.c b/src/core/ddsi/src/ddsi_tkmap.c
index a3bed8dc..a8246238 100644
--- a/src/core/ddsi/src/ddsi_tkmap.c
+++ b/src/core/ddsi/src/ddsi_tkmap.c
@@ -10,6 +10,7 @@
 
 #include <assert.h>
 #include <string.h>
+#include <stdio.h>
 
 #include "dds/ddsrt/heap.h"
 #include "dds/ddsrt/log.h"
@@ -112,11 +113,23 @@ void ddsi_tkmap_free (struct ddsi_tkmap * map)
 
 uint64_t ddsi_tkmap_lookup (struct ddsi_tkmap * map, const struct ddsi_serdata * sd)
 {
+  FILE *f = fopen("D:\\Work\\FastCycloneDdsCsharpBindings\\debug_tkmap.log", "a");
+  if(f) { 
+      fprintf(f, "ddsi_tkmap_lookup: map=%p, sd=%p\n", map, sd); 
+      if (sd) {
+           // access some fields to check validity
+           fprintf(f, "ddsi_tkmap_lookup: checking sd. hash=%u\n", sd->hash);
+      }
+      fflush(f);
+  }
+
   struct ddsi_tkmap_instance dummy;
   struct ddsi_tkmap_instance * tk;
   assert (ddsi_thread_is_awake ());
   dummy.m_sample = (struct ddsi_serdata *) sd;
+  if(f) { fprintf(f, "ddsi_tkmap_lookup: calling ddsrt_chh_lookup\n"); fflush(f); }
   tk = ddsrt_chh_lookup (map->m_hh, &dummy);
+  if(f) { fprintf(f, "ddsi_tkmap_lookup: ddsrt_chh_lookup returned tk=%p\n", tk); fclose(f); }
   return (tk) ? tk->m_iid : DDS_HANDLE_NIL;
 }
 
-- 
2.50.1.windows.1

